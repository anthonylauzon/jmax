%{
#include <stdio.h>
#include <unistd.h>

#include <fts/fts.h>
#define YYSTYPE fts_atom_t
#include <ftsprivate/parserdata.h>

#define free fts_free

#define YYPARSE_PARAM data
#define YYLEX_PARAM data

#define yylex( lvalp, data) (*((fts_parser_data_t *)data)->yylex)( lvalp, data)

static int yyerror( const char *msg);

#define action_int (*((fts_parser_data_t *)data)->actions->_int)
#define action_float (*((fts_parser_data_t *)data)->actions->_float)
#define action_symbol (*((fts_parser_data_t *)data)->actions->_symbol)
#define action_begin_expression (*((fts_parser_data_t *)data)->actions->_begin_expression)
#define action_end_expression (*((fts_parser_data_t *)data)->actions->_end_expression)

%}

%pure_parser

/* **********************************************************************
 *
 * Tokens
 *
 */

%token FTS_TOKEN_INT
%token FTS_TOKEN_FLOAT
%token FTS_TOKEN_SYMBOL
%token FTS_TOKEN_DOLLAR "$"
%token FTS_TOKEN_SEMICOLON ";"
%token FTS_TOKEN_LPAR "("
%token FTS_TOKEN_RPAR ")"
%token FTS_TOKEN_DOT "."
%token FTS_TOKEN_LSBRA "["
%token FTS_TOKEN_RSBRA "]"

%%

/* **********************************************************************
 *
 * Rules
 *
 */

program: expression_list ;

expression_list: expression_list ";" expression 
	| expression ;

expression: { action_begin_expression(); } tuple { action_end_expression(); } ;

tuple: tuple term
	| /* empty */ ;

term: primitive
	| invocation
	| "(" expression ")";

primitive: FTS_TOKEN_INT { action_int( &($1)); }
	| FTS_TOKEN_FLOAT { action_float( &($1)); }
	| FTS_TOKEN_SYMBOL { action_symbol( &($1)); }
	| reference ;

reference: variable
	| array;

variable: "$" FTS_TOKEN_SYMBOL {} ;

array: variable "[" term "]" {} ;

arguments: arguments term
	   | /* empty */ ;

invocation: dot_expression arguments;

dot_expression: reference dot_list ;

dot_list: dot_list "." FTS_TOKEN_SYMBOL 
	| "." FTS_TOKEN_SYMBOL;

%%

/* **********************************************************************
 *
 * Parser extra functions
 *
 */

/*
 * These definitions are used only in the extra functions
 */

/*
  Stack organization:

Before calling a method or outputing a message:
           <- top
arg3  
arg2
arg1       <- fp
savedfp
retval
arg2'
arg1'
savedfp'
retval'

After poping one frame:


arg3  
arg2
arg1
savedfp      <- top
retval
arg2'
arg1'        <- fp
savedfp'
retval'

*/

static parser_actions_t standard_actions;

static fts_stack_t interpreter_stack;
static int fp = 0;

#define PUSH(V) fts_stack_push( &interpreter_stack, fts_atom_t, (V))
#define POP(N) fts_stack_pop( &interpreter_stack, (N))

#define TOP fts_stack_get_top( &interpreter_stack)
#define BASE ((fts_atom_t *)fts_stack_get_base( &interpreter_stack))

extern int fts_string_lex( YYSTYPE *lvalp, void *data);
extern int fts_atoms_lex( YYSTYPE *lvalp, void *data);


static int yyerror( const char *msg)
{
  fprintf( stderr, "%s\n", msg);

  return 0;
}

int fts_parse_atoms( int ac, fts_atom_t *at)
{
  fts_parser_data_t data;

  data.actions = &standard_actions;
  data.yylex = fts_atoms_lex;
  data.ac = ac;
  data.at = at;
  data.buffer = NULL;

  return yyparse( &data);
}

/*
  problem: some code in the body of this function needs YY_BUFFER_STATE which is generated by flex.
  so it must either be in scanner.l or use an intermediate function defined in scanner.l
*/
int fts_parse_string( const char *s)
{
  fts_parser_data_t data;

  data.actions = &standard_actions;
  data.yylex = fts_string_lex;
  data.ac = 0;
  data.at = NULL;
  data.buffer = (char *)s;

  return yyparse( &data);
}

/* **********************************************************************
 *
 * Action functions
 *
 */
static void print_stack( const char *msg)
{
  int i, current_fp;
  fts_atom_t *p = BASE;

  post( "%s:\n", msg);

  current_fp = fp;

  for ( i = TOP - 1; i >= 0; i--)
    {
      post( "[%2d]", i);
      if ( i == current_fp - 1)
	{
	  post( "* ");
	  current_fp = fts_get_int( p+i);
	}
      else
	post( "  ");

      post_atoms( 1, p+i);
      post( "\n");
    }
}

static void push_frame()
{
  fts_atom_t a;

  /* return value */
  fts_set_void( &a);
  PUSH( a);

  /* saved frame pointer */
  fts_set_int( &a, fp);
  PUSH( a);
  fp = TOP;

  print_stack( "Stack after pushing frame");
}

static void pop_frame()
{
  int old_fp;

  print_stack( "Stack before poping frame");

  old_fp = fp;
  fp = fts_get_int( BASE + fp - 1);
  POP( TOP - old_fp + 1);

  print_stack( "Stack after poping frame");
}

static void push_value( const fts_atom_t *yylval)
{
  PUSH( *yylval);
}

#ifdef HACK_DEBUG

/* **********************************************************************
 * 
 * Debug code
 *
 */

static void fts_stdoutstream_output(fts_bytestream_t *stream, int n, const unsigned char *buffer)
{
  write( 1, buffer, n);
}

static void fts_stdoutstream_output_char(fts_bytestream_t *stream, unsigned char c)
{
  write( 1, &c, 1);
}

static void fts_stdoutstream_flush(fts_bytestream_t *stream)
{
}

static void fts_stdoutstream_init(fts_object_t *o, int winlet, fts_symbol_t s, int ac, const fts_atom_t *at)
{
  fts_bytestream_init( (fts_bytestream_t *) o);
  fts_bytestream_set_output( (fts_bytestream_t *) o, fts_stdoutstream_output, fts_stdoutstream_output_char, fts_stdoutstream_flush);
}

static void fts_stdoutstream_receive(fts_object_t *o, int winlet, fts_symbol_t s, int ac, const fts_atom_t *at)
{
  post( "Parsing ?\n");
  fts_parse_string( NULL);
}

static fts_status_t fts_stdoutstream_instantiate(fts_class_t *cl, int ac, const fts_atom_t *at)
{
  fts_class_init(cl, sizeof(fts_bytestream_t), 0, 0, 0);
  fts_bytestream_class_init(cl);
  fts_method_define_varargs(cl, fts_SystemInlet, fts_s_init, fts_stdoutstream_init);
  fts_method_define_varargs(cl, fts_SystemInlet, fts_s_sched_ready, fts_stdoutstream_receive);

  return fts_Success;
}
#endif

/* **********************************************************************
 *
 * Kernel initialization
 *
 */
static void init_actions( void)
{
  standard_actions._int = push_value;
  standard_actions._float = push_value;
  standard_actions._symbol = push_value;
  standard_actions._begin_expression = push_frame;
  standard_actions._end_expression = pop_frame;
}

void fts_kernel_parser_init( void)
{
  fts_stack_init( &interpreter_stack, fts_atom_t);
  init_actions();
}

void fts_parser_config( void)
{
#ifdef HACK_DEBUG
  {
    fts_metaclass_t *stdoutstream_type;
    fts_bytestream_t *stream;

    stdoutstream_type = fts_class_install( fts_new_symbol("stdoutstream"), fts_stdoutstream_instantiate);
    stream = (fts_bytestream_t *)fts_object_create( stdoutstream_type, 0, 0);
    fts_set_default_console_stream( stream);

    fts_sched_add( (fts_object_t *)stream, FTS_SCHED_ALWAYS);  
  }
#endif
}
