<html>

<!--                                                                    -->
<!-- jMax                                                               -->
<!--                                                                    -->
<!-- Copyright (C) 1999 by IRCAM                                        -->
<!-- All rights reserved.                                               -->
<!--                                                                    -->
<!-- This program may be used and distributed under the terms of the    -->
<!-- accompanying LICENSE.                                              -->
<!--                                                                    -->
<!-- This program is distributed WITHOUT ANY WARRANTY. See the LICENSE  -->
<!-- for DISCLAIMER OF WARRANTY.                                        -->
<!--                                                                    -->

<head>
<title>jMax Documentation - Control Objects Developer's Guide</title>
</head>
     
<body text="#000000" bgcolor="#cccccc">

<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0>
<TR>
  <TD ALIGN=LEFT>
    <A HREF="http://www.ircam.fr/jmax/"><IMG SRC="../../images/jmax_logo_tiny.gif" BORDER=0 ALT="jMax"></A>
  </TD>
  <TD ALIGN=RIGHT>
    <A HREF="http://www.ircam.fr/"><IMG SRC="../../images/ircam_banner.gif" BORDER=0 ALT="IRCAM - Centre Georges Pompidou"></A>
  </TD>
</TR>
</TABLE>
<BR>

<p>
<UL TYPE=SQUARE>
  <LI><A HREF=../index.html>Documentation</A>
  <UL TYPE=SQUARE>
    <LI><A HREF=index.html>Developer Documentation</A>
  </UL>
</UL>

<p>
<font size=+3 color=#FFFFFF><b>Control Objects Developer's Guide</b></font>

<p>
<hr noshade size=1>
<ul type=dot>
  <li><a href="#disclaimer">Disclaimer</A>
  <li> <a href="#Introduction">Introduction</a>
  <li> <a href="#Objects">Objects</a>
  <li> <a href="#Methods">Methods</a>
  <li> <a href="#Message Sending">Message Sending</a>
  <li> <a href="#Messages and Methods">Messages and Methods</a>
  <li> <a href="#System Methods">System Methods</a>
  <li> <a href="#Outlet Typing">Outlet Typing</a>
  <li> <a href="#Classes">Classes</a>
  <li> <a href="#Metaclasses">Metaclasses</a>
  <li> <a href="#Object And Class Properties">Object And Class Properties</a>
  <li> <a href="#Examples">Examples</a>
</ul>

<p>
<hr noshade size=1>

<TABLE WIDTH=100% BORDER=0 CELLSPACING=1 CELLPADDING=20 BGCOLOR=#FFFFFF>
<TR><TD>


<a name="disclaimer"> <H2> Disclaimer </H2> </a>

<p>
The API presented here may be subject to small changes.

<p>
This first version of the documentation is adapted from the <quote>FTS Message System 
Programming Guide</quote> and some inconsistencies may subsist.


<!-- ---------------------------------------------------------------------- -->
<p>
<hr>
<a name="Introduction"><h2>Introduction</h2></a>

<p>
This documentation introduces the jMax objects API, known in Max-Opcode as the <i>"external"</i>
objects API. As a consequence of the client/server architecture of jMax, these objects are
loaded and executes in the jMax server, called FTS. The documentation will then use the 
term <i>FTS message system</i> to denote the server objects API.

<p>
The FTS message system combines an object system and a message passing
system. It is a new definition of Max/FTS message system already implemented
in Max/Macintosh and in previous versions of Max/FTS on the ISPW.

<p>
The main concepts of FTS message system are:
<ul>
<li> <i>objects</i> : a FTS object is a <i>state</i> (some memory holding values)
and a set of <i>connections</i> used for message sending between objects
<li> <i>messages</i> : a FTS message is a <i>selector</i> (a symbol) and a list
of arguments which are <i>atoms</i>
<li> <i>inlets</i> and <i>outlets</i> :to each object is associated a set of receptors, the 
inlets and a set of emitters, the outlets. An inlet receives messages and messages can be emitted
on outlets
<li> <i>methods</i> : the reception of a message on an inlet triggers the call of a method. A FTS
method is a C function with a particular signature
<li> <i>classes</i> : a FTS class is a set of objects having a common <i>interface</i>
regarding the object model
<li> <i>metaclasses</i> : a FTS metaclass is a set of classes sharing common behavior
</ul>


<!-- ---------------------------------------------------------------------- -->
<p>
<hr>
<a name="Objects"><h2>Objects</h2></a>

<p>
A FTS object is an abstraction that store information and 
can receive and emit messages. To an object is allocated some
memory storing its <i>state</i> as a C structure.

<pre>
typedef struct {
  fts_object_t o;   /* MUST BE FIRST STRUCTURE MEMBER */
  long n;           /* the state of a integer object */
} integer_t;
</pre>

<p>
<strong>Attention !!!</strong> A FTS object must always have a first structure member
of type <code>fts_object_t</code>. This implements in C the fact that all FTS objects
inherits from the <code>fts_object_t</code> type.

<p>
The only "system" member of the structure which is made mandatory by the FTS object
 system is the first member of type <code>fts_object_t</code>. The other members of the structure 
are "user" members and are not handled by the system.

<p>
An number of functions or macros are provided to get some of the object
characteristic:

<pre>
int  
fts_object_get_outlets_number(fts_object_t *<i>obj</i>);
</pre>

Return the number of outlets the object <i>obj</i> have.

<pre>
int  
fts_object_get_inlets_number(fts_object_t *<i>obj</i>);
</pre>

Return the number of inlets the object <i>obj</i> have.

<pre>
const char *fts_object_get_class_name(fts_object_t *<i>obj</i>);
</pre>

Return as a C string the name of the object class; to be used
only for user messages.



<!-- ---------------------------------------------------------------------- -->
<p>
<hr>
<a name="Methods"><h2>Methods</h2></a>

<p>
A <i>method</i> is a C-function that will be called when an object receives
a message on one of its inlets. It has a standard signature, and all the
methods access their arguments the same way.

<ul>
<li> <a href="#Method Signature">Method Signature</a>
<li> <a href="#Method Arguments">Method Arguments</a>
<li> <a href="#Accessing Arguments">Accessing Arguments</a>
<li> <a href="#List of Access Macros">List of Access Macros</a>
</ul>


<a name="Method Signature"><h3>Method Signature</h3></a>

<p>
All FTS methods have the same <i>signature</i>, i.e. the same number of arguments
of the same types. This signature is the following :

<code>void method( fts_object_t *<i>object</i>, int <i>winlet</i>, fts_symbol_t <i>selector</i>, int <i>ac</i>,  const fts_atom_t *<i>at</i>)</code> <p>

<p>
The arguments of the method have the following meaning :
<dl>
<dt> <i> object</i> <dd> 
a pointer to the object receiving the message
<dt> <i> winlet</i> <dd> 
the number of the inlet on which message was received
<dt> <i> selector</i> <dd> 
the message selector, a symbol. The <code>fts_symbol_t</code>
data structure is discussed in details in <a href="kernel_reference.html">FTS Kernel Reference Manual</a>.
<dt> <i> ac</i> <dd> 
the number of arguments
<dt> <i> at</i> <dd> 
the arguments array
</dl>


<a name="Method Arguments"><h3>Method Arguments</h3></a>

<p>
The arguments of a method are of type <code>fts_atom_t</code>. The <code>fts_atom_t</code>
data structure is discussed in details in <a href="kernel_reference.html">FTS Kernel Reference Manual</a>.

<p>
<b>Attention !!!</b> The arguments are passed by the message system as an 
array of <b>constant</b> atoms.
This means that a method cannot modify its arguments. Modifying the arguments
of a method in the body of the method can lead to unpredictable side effects.
If this is needed for convenience, the arguments must first be <i>copied</i>.


<a name="Accessing Arguments"><h3>Accessing Arguments</h3></a>

<p>
A method access its arguments via <i>access macros</i>, which handle both 
accessing the atoms and giving a default value if corresponding 
argument is optional.

<p>
<b>Attention !!!</b> It is strongly recommended to use the arguments access
macros. Accessing directly the members of the <code>fts_atom_t</code> structure
is guaranteed not to work across different releases of FTS, because <code>fts_atom_t</code>
implementation may change.

<p>
This is an example of a simple method, taking one argument of type <code>long</code>,
with a default value of 0, which stores the value of this argument in the state
of the object :

<pre>
void integer_in1( fts_object_t *object, int winlet, fts_symbol_t selector, 
                  int ac, const fts_atom_t *at)
{
  integer_t *this = (integer_t *)object;

  this->n = fts_get_int_arg( ac, at, 0, 0);
}
</pre>

<p>
In this method, the <i>object</i> argument, typed as an <code>fts_object_t *</code>
is in fact a pointer to an object of type <code>integer_t</code> (defined earlier),
which first 
structure member is of type <code>fts_object_t</code>. This explains the cast
made at beginning of method.


<a name="List of Access Macros"><h3>List of Access Macros</h3></a>

<p>
Below is the list of available access macros :
<dl>
<dt> <code> fts_get_int_arg( <i>AC</i>, <i>AT</i>, <i>N</i>, <i>DEFAULT</i>)</code> <dd> 
gets an argument of type <code>int</code>
<dt> <code> fts_get_float_arg( <i>AC</i>, <i>AT</i>, <i>N</i>, <i>DEFAULT</i>)</code> <dd> 
gets an argument of type <code>float</code>
<dt> <code> fts_get_symbol_arg( <i>AC</i>, <i>AT</i>, <i>N</i>, <i>DEFAULT</i>)</code> <dd> 
gets an argument of type <code>fts_symbol_t</code>
<dt> <code> fts_get_string_arg( <i>AC</i>, <i>AT</i>, <i>N</i>, <i>DEFAULT</i>)</code> <dd> 
gets an argument of type <code>const char *</code>
<dt> <code> fts_get_obj_arg( <i>AC</i>, <i>AT</i>, <i>N</i>, <i>DEFAULT</i>)</code> <dd> 
gets an argument of type <code>void *</code>
</dl>

<p>
The macro arguments have the following meaning :
<dl>
<dt> <i> AC</i> <dd> 
the number of atoms in array <i>AT</i>
<dt> <i> AT</i> <dd> 
the atom array
<dt> <i> N</i> <dd> 
the index of the requested argument
<dt> <i> DEFAULT</i> <dd> 
the default value for the requested argument
</dl>

<p>
All these macros have the same semantic : if <i>N</i> is less than <i>AC</i>,
return the value of atom <i>N</i> in array <i>AT</i>, else return value <i>DEFAULT</i>.


<!-- ---------------------------------------------------------------------- -->
<p>
<hr>
<a name="Message Sending"><h2>Message Sending</h2></a>
 
<p>
Messages can be send on the outlets of an object, using the
<code>fts_outlet_send</code> function.

<ul>
<li> <a href="#The fts_outlet_send Function">The <code>fts_outlet_send</code> Function</a>
<li> <a href="#Message Sending Example">Message Sending Example</a>
<li> <a href="#Message Arguments Building">Message Arguments Building</a>
<li> <a href="#Message Selectors">Message Selectors</a>
</ul>


<a name="The fts_outlet_send Function"><h3>The <code>fts_outlet_send</code> Function</h3></a>

<p>
<code>fts_status_t  fts_outlet_send( fts_object_t *<i>object</i>, int <i>woutlet</i>, fts_symbol_t <i>selector</i>, int <i>argc</i>, const fts_atom_t *<i>args</i>) </code>

<p>
The arguments of <code>fts_outlet_send</code> have the following meaning :
<dl>
<dt> <i> object</i> <dd> 
the object from which outlet the message is send
<dt> <i> woutlet</i> <dd> 
the number of the outlet on which the message is send
<dt> <i> selector</i> <dd> 
the message selector, a symbol 
<dt> <i> argc</i> <dd> 
the count of arguments of the message
<dt> <i> args</i> <dd> 
the arguments of the message, an array of atoms
</dl>


<a name="Message Sending Example"><h3>Message Sending Example</h3></a>

<p>
Message sending is most of the time done in the body of a method, as in the following
example, a method sending on the outlet the content of the state of the object :
<pre>
void integer_bang( fts_object_t *object, int winlet, fts_symbol_t selector,
                   int ac, const fts_atom_t *at)
{
  integer_t *this = (integer_t *)object;
  fts_atom_t a;

  fts_set_int( &a, this->n);
  fts_outlet_send( object, 0, fts_s_int, 1, &a);
}
</pre>


<a name="Message Arguments Building"><h3>Message Arguments Building</h3></a>

<p>
Typically, sending a message is done in 2 phases :
<ul>
<li>format the arguments in an array of atoms. This is done using
the <code>fts_atom_t</code> data structure access macros
<li>call the <code>fts_outlet_send</code> function, passing it the arguments
array
</ul>

<p>
<b>Attention !!!</b> It is strongly recommended to use the atoms setting
macros to format the arguments. Accessing directly the members of the <code>fts_atom_t</code> structure
is guaranteed not to work across different releases of FTS, because <code>fts_atom_t</code>
implementation may change.


<a name="Message Selectors"><h3>Message Selectors</h3></a>
 
<p>
A message selector is a <code>fts_symbol_t</code>. The <code>fts_symbol_t</code> 
data structure is not documented yet.
 
<p>
There is a number of predefined selectors which are defined in the header 
files for the message system. Below is the list of already defined selectors:
<dl>
<dt> <code> fts_s_int </code> <dd> 
"int"
<dt> <code> fts_s_float</code> <dd> 
"float"
<dt> <code> fts_s_bang</code> <dd> 
"bang"
<dt> <code> fts_s_list</code> <dd> 
"list"
<dt> <code> fts_s_symbol</code> <dd> 
"symbol"
<dt> <code> fts_s_set</code> <dd> 
"set"
<dt> <code> fts_s_sig</code> <dd> 
"sig"
<dt> <code> fts_s_put</code> <dd> 
"put"
</dl>
 
<p>
If a selector which is not already defined is
needed, the <code>fts_new_symbol</code> or <code>fts_new_symbol_copy</code>
functions generates a new symbol:
<ul>
<li>fts_symbol_t <code>fts_new_symbol( const char *s)</code> returns a new symbol
containing string s. <strong>Note:</strong> the passed string is not copied.
<li>fts_symbol_t <code>fts_new_symbol_copy( const char *s)</code> returns a new symbol
containing string s. <strong>Note:</strong> the passed string is copied. This function
is used when the passed string is not a constant.
</ul>


<!-- ---------------------------------------------------------------------- -->
<p>
<hr>
<a name="Messages and Methods"><h2>Messages and Methods</h2></a>

<p>
Method definition is done using the <code>fts_method_define</code> function, 
which is usually called when initializing the class. This function defines
to which message the method will be associated, and which kind of
arguments it expects.

<ul>
<li> <a href="#The fts_method_define Function">The <code>fts_method_define</code> Function</a>
<li> <a href="#Method Arguments Types">Method Arguments Types</a>
<li> <a href="#Method Definition Example">Method Definition Example</a>
<li> <a href="#Methods with Variable Arguments Number">Methods with Variable Arguments Number</a>
</ul>

<a name="The fts_method_define Function"><h3>The <code>fts_method_define</code> Function</h3></a>

<code>fts_status_t fts_method_define( fts_class_t *<i>class</i>, int <i>winlet</i>, fts_symbol_t <i>selector</i>, fts_method_t <i>method</i>, int <i>argc</i>, fts_type_t *<i>argtypes</i> )</code> <p>

<p>
The arguments of <code>fts_method_define</code> have the following meaning :
<dl>
<dt> <i> class</i> <dd> 
the class in which the definition is valid
<dt> <i> winlet</i> <dd> 
the number of the inlet for which the definition is valid
<dt> <i> selector</i> <dd> 
the associated message selector : when receiving a message having this
selector, the method will be called with the message arguments, after 
arguments type checking
<dt> <i> method</i> <dd> 
the method : a function having the signature already defined
<dt> <i> argc</i> <dd> 
the count of expected arguments
<dt> <i> argtypes</i> <dd> 
the types of expected arguments : the type checking mechanism will be detailed 
later
</dl>


<a name="Method Arguments Types"><h3>Method Arguments Types</h3></a>
 
<p>
When defining a method associated with a message, it is necessary to define 
the arguments types which are expected. This will be used by the system
to do a type checking, at connection-time and at run-time (with some
optimizations).


<p>
This type definition is done with 
the <i>argtypes</i> argument of function <code>fts_method_define</code>.
This argument is an array of elements of type <code>fts_type_t</code>,
each element defining the expected type of the argument having
same index in the arguments array.
        
<p>
The elements of the array <i>argtypes</i> can take the following values:
<dl>
<dt> <code> fts_t_int</code> <dd> 
argument must be of type <code>int</code>, initialized with <code>fts_set_int</code>
<dt> <code> fts_t_float</code> <dd> 
argument must be of type <code>float</code>, initialized with <code>fts_set_float</code>
<dt> <code> fts_t_symbol</code> <dd> 
argument must be of type <code>symbol</code>, initialized with <code>fts_set_symbol</code>
<dt> <code> fts_t_ptr</code> <dd> 
argument must be of type <code>ptr</code>, initialized with <code>fts_set_ptr</code>
</dl>

<p>
For method taking one argument, the function <code>fts_type_get_selector</code>
returns the selector (as a <code>fts_symbol_t</code>) associated with the type.



<a name="Method Definition Example"><h3>Method Definition Example</h3></a>

<p>
Below is an example showing the installation of the method <code>integer_in1</code>
already defined for the <code>integer</code> object. This method is defined for
inlet number 1 and takes one argument of type <code>int</code>.

<pre>
fts_status_t integer_instantiate( fts_class_t *class, int ac, fts_atom_t *at)
{
  fts_type_t t;

  t = fts_t_int;
  fts_method_define( class, 1, fts_type_get_selector(fts_t_int), integer_in1, 1, &t);
}
</pre>


<a name="Methods with Variable Arguments Number"><h3>Methods with Variable Arguments Number</h3></a>

<p>
A method accepting a variable number of arguments is defined using function 
<code>fts_method_define_optargs</code>.

<code>fts_status_t fts_method_define_optargs( fts_class_t *<i>class</i>, int <i>winlet</i>, fts_symbol_t <i>selector</i>, fts_method_t <i>method</i>, int <i>argc</i>, fts_type_t *<i>argtypes</i>, int <i>min_argc</i> )</code> <p>

<p>
The arguments of <code>fts_method_define_optargs</code> are similar to <code>fts_method_define</code>,
except for the last supplementary arguments:
<dl>
<dt> <i> min_argc</i> <dd> 
the minimum count of expected arguments
</dl>

<p>
Below is an example showing the installation of a method <code>integer_incr</code>
for the <code>integer</code> object. This method takes zero or one argument of type <code>int</code>.

<pre>

void integer_incr( fts_object_t *object, int winlet, fts_symbol_t selector, 
                  int ac, const fts_atom_t *at)
{
  integer_t *this = (integer_t *)object;
  int incr = fts_get_int_arg( ac, at, 0, 1);

  this->n += incr;
}

fts_status_t integer_instantiate( fts_class_t *class, int ac, fts_atom_t *at)
{
  fts_type_t t;

  t = fts_t_int;
  fts_method_define_optargs( class, 0, fts_new_symbol("incr"), integer_incr, 1, &t, 0);
}
</pre>


<!-- ---------------------------------------------------------------------- -->
<p>
<hr>
<a name="System Methods"><h2>System Methods</h2></a>

<p>
Some of the methods of a class can be "system" methods, handling
system level functions. These functions are now : object initialization 
and deletion, objects connection and disconnection.


<p>
All the system methods are associated to messages received on the
<i>system inlet</i>, which is a symbolic constant defined by
the message system. Except this, system methods are strictly 
identical to standard methods.


<ul>
<li> <a href="#The init Method">The <code>init</code> Method</a>
<li> <a href="#The delete Method">The <code>delete</code> Method</a>
<li> <a href="#release">The <code>release</code> and <code>redefining</code> Method</a>
<li> <a href="#The assist Method">The <code>assist</code> Method</a>
</ul>


<a name="The init Method"><h3>The <code>init</code> Method</h3></a>

<p>
The init method handles the initialization of an object, but doesn't need to handle
memory allocation. It is very similar to a C++ <i>constructor</i>. If it is defined,
it is called
automatically by the system when an object is created. 


<p>
The <code>init</code> method arguments, are the object creation arguments, including
the class name; i.e. using FTS with the standard Max editor, the arguments of the
init arguments are the content of the object box.
The declaration of the types of these so-called <i>creation</i> arguments must take 
into account this feature.

<p>
The selector of the <code>init</code> method is the predefined symbol <code>fts_s_init</code>.

<p>
Below is the example of the init method for the <code>integer</code> object
already defined. This method just initialize the state of the object
with the value of its argument.

<pre>
void integer_init( fts_object_t *object, int winlet, fts_symbol_t selector, 
                   int ac, const fts_atom_t *at)
{
  integer_t *this = (integer_t *)object;

  post( "initializing an object of class %s", fts_symbol_name(fts_get_symbol_arg( ac, at, 0, 0)));
  this->n = fts_get_int_arg( ac, at, 1, 0);
}
</pre>


<p>
This method is installed by the following code :
<pre>
fts_status_t integer_instantiate( fts_class_t *class, int ac, fts_atom_t *at)
{
  fts_type_t t[2];

  t[0] = fts_t_symbol;
  t[1] = fts_t_int;
  fts_method_define( class, fts_SystemInlet, fts_s_init, integer_init, 2, t);
}
</pre>


<p>
The init method can detect an error in its argument; in order to signal
the error, the following function should be called:

<pre>
extern void fts_object_set_error(fts_object_t *obj, const char *format, ...);
</pre>

<p>
The obj argument should be the object being initialized; the format
argument is a string in the "printf" format, followed by a variable
number of arguments; the user interface will then show the object
as an error object (red) and the string passed by format and the
following arguments will be used as error message for the object.
<p>

<a name="The delete Method"><h3>The <code>delete</code> Method</h3></a>

<p>
The delete method handles the destruction of an object, but doesn't need to handle
memory de-allocation. It is very similar to a C++ <i>destructor</i>. If it is defined,
it is called automatically by the system when an object is deleted, without arguments.

<p>
The selector of the <code>delete</code> method is the predefined symbol <code>fts_s_delete</code>.

<p>
A delete method can be installed for the <code>integer</code> object by the following code :

<pre>
fts_status_t integer_instantiate( fts_class_t *class, int ac, fts_atom_t *at)
{
  fts_method_define( class, fts_SystemInlet, fts_s_delete, integer_delete, 
                     0, 0);
}
</pre>

<a name="release"><h3>The <code>release</code> and the <code>redefining</code> Methods</h3></a>
<p>
An object can be redefined by an other one as the result of two kind
of actions: the direct editing of the object in the user interface, or
an implicit change of arguments to the change of a patcher variable
value.
<p>
In both case, the object is substited with a newly instantiated one;
before deleting the old one, the system give an opportunity to copy
some of the state of the old object to the new one; this can be very
convenient if this state is a set of persistent data, like a table,
that we don't want to loose just because one secondary parameter of
the object changed; or for example, to allow reusing an edited data
set on a slightly different object.
<p>
This opportunity is implemented by a modified deleting sequence; if
the object being substitued implement a "release" method, then this is
called; in this method the object should free global resources, like a
global name, but it should not free internal resources, like a table
content; then the system send to the newly created object a
"redefining" (the <code>fts_s_redefining</code> C variable is defined)
message to the system inlet, with as only argument the old object; the
message is sent after the init message; it is the responsability of
the method implementation to check that the old object is of a
meaningful type; finally, the "delete" message is sent to the old
object.<br> If the old object do not define a method for the
"release", just the standard "delete" message is sent, and no
"redefining" is tryed.
<p>
The "redefining" method should not send messages, either from the old or from
the new object, because there is no guarantee that the connections structure
are consistent  at this point in time for either of two objects.
<p>

<a name="The assist Method"><h3>The <code>assist</code> Method</h3></a>
<p>
The assist method allow an object to define a short help describing
itself, and its inlet and outlet roles; this help will be shown in the
status line when the mouse pass over the object or the object inlets
and outlets.
<p>
The assist method receive either one or two arguments describing the
help requested; the first is always a symbol between "object", "inlet"
and "outlet"; in the case of a inlet or outlet, the following argument
is the position of the inlet/outlet.
<p>
The message should be sent with the following function:
<pre>
extern void fts_object_blip(fts_object_t *obj, const char *format, ...)
</pre>
Where obj should be the current object, the format argument is in 
<code>printf</code> syntax, and the following arguments are used with
format to produce the message.


<!-- ---------------------------------------------------------------------- -->
<p>
<hr>
<a name="Outlet Typing"><h2>Outlet Typing</h2></a>


<p>
The outlets of an object can be statically <i>typed</i>. If an outlet
is going to send only one kind of message selector, this selector and
the types of associated arguments can be declared using the <code>fts_outlet_type_define</code>
function.

<ul>
<li> <a href="#The fts_outlet_type_define Function">The <code>fts_outlet_type_define</code> Function</a>
<li> <a href="#Outlet Typing Example">Outlet Typing Example</a>
</ul>


<a name="The fts_outlet_type_define Function"><h3>The <code>fts_outlet_type_define</code> Function</h3></a>


<code>fts_status_t fts_outlet_type_define( fts_class_t *<i>class</i>, int <i>woutlet</i>, fts_symbol_t <i>selector</i>,int <i>argc</i>, fts_type_t *<i>argtypes</i>)</code> <p>

<p>
The arguments of <code>fts_outlet_type_define</code> have the following meaning :
<dl>
<dt> <i> class</i> <dd> 
the class for which the type is defined
<dt> <i> woutlet</i> <dd> 
the number of the outlet for which the type is defined
<dt> <i> selector</i> <dd> 
the associated message selector
<dt> <i> argc</i> <dd> 
the count of arguments
<dt> <i> argtypes</i> <dd> 
the types of message arguments
</dl>

<p>
The types of message arguments are the same as for function <code>fts_method_define</code>.
 

<p>
The type of an outlet will be used by the system
to do a type checking, at connection-time and at run-time (when needed).

<p>
Outlet typing do not affect the efficiency of method calling; the method dispatching
use a entry dynamic cache that optimize methods calls for all objects,
not only statically type ones.

<p>
The type of an outlet is <i>unique</i> : 
if an outlet is supposed to send different kinds of messages, then
it must <i>not</i> be typed; this means that the symbol <code>fts_s_anything</code>
is not accepted as argument to this function.


<a name="Outlet Typing Example"><h3>Outlet Typing Example</h3></a>

<p>
The following code defines the type of the outlet for the <code>integer</code>
object. The outlet number 1 is defined to send only one type of message,
with selector <code>int</code> and one argument of type <code>int</code>.

<pre>
fts_status_t integer_instantiate( fts_class_t *class, int ac, fts_atom_t *at)
{
  fts_type_t a;

  a = fts_t_int;
  fts_outlet_type_define(class, 0, fts_type_get_selector( fts_t_int), 1, &t);
}
</pre>


<!-- ---------------------------------------------------------------------- -->
<p>
<hr>
<a name="Classes"><h2>Classes</h2></a>


<p>
The definition of a class is the definition of :
<ul>
<li> its name
<li>the size of the objects of the class
<li>the number of inlets of the objects of the class
<li>the number of outlets of the objects of the class
<li>for each inlet, a list of (message selectors, associated method, arguments types)
<li>for each outlet, the eventual message selector and arguments types
</ul>

<p>
It comes from this definition that all objects of a class have <i>same</i>
number of inlets and outlets. The mechanism for having variable number of inlets
and outlets is the <i>metaclass</i> described below.

<p>
When a new class is installed, it is not fully initialized. The complete initialization
will be done on demand, at the first instantiation of the class (i.e. when the first 
object of the class is created). The function that is responsible for this task
is called the <i>instantiation function</i>. 


<ul>
<li> <a href="#Class Installation">Class Installation</a>
<li> <a href="#The Class Instantiation Function">The Class Instantiation Function</a>
<li> <a href="#The fts_class_init Function">The <code>fts_class_init</code> Function</a>
<li> <a href="#Class Instantiation Function Example">Class Instantiation Function Example</a>
</ul>


<a name="Class Installation"><h3>Class Installation</h3></a>

<p>
A class is installed with the <code>fts_class_install</code> function, that declares its
name and its instantiation function.

<p>
<code>fts_status_t fts_class_install( fts_symbol_t <i>name</i>, fts_instantiate_fun_t <i>instantiate_fun</i>)</code>

<p>
The arguments of <code>fts_class_install</code> have the following meaning :
<dl>
 <dt> <i> name</i>
  <dd> the name of the class
 <dt> <i> instantiate_fun</i>
  <dd> the instantiation function of the class
</dl>

<p>
For simplicity, aliases (usually abbreviations) can be defined for a class name, using the 
<code>fts_class_alias</code> function: <br>
<code>void fts_class_alias( fts_symbol_t <i>new_name</i>, fts_symbol_t <i>old_name</i>)</code> <br>
After a call to <code>fts_class_alias</code>, the name <i>new_name</i>, when used as a class name, 
will be automatically substituted by <i>old_name</i>.


<p>
Below is an example of use of the <code>fts_class_install</code> and <code>fts_class_alias</code>
functions:
<pre>
void integer_config( void)
{
  /* Install the metaclass "integer" */
  fts_class_install( fts_new_symbol( "integer"), integer_instantiate);

  /* Register "i" to be an alias for "integer" */
  fts_class_alias( fts_new_symbol( "i"), fts_new_symbol( "integer"));
}
</pre>


<a name="The Class Instantiation Function"><h3>The Class Instantiation Function</h3></a>

<p>
The signature of a class instantiation function is the following :

<p>
<code>fts_status_t <i>my_class_instantiate</i>( fts_class_t *<i>class</i>, int <i>ac</i>, fts_atom_t *<i>at</i>)</code> 

<p>
The arguments of the class instantiation function have the following meaning :
<dl>
<dt> <i> class</i> <dd> 
the class that is to be defined
<dt> <i> ac</i> <dd> 
the number of arguments
<dt> <i> at</i> <dd> 
the arguments array. These are the creation arguments of the first object of the class, and
are usually meaningless for a class.
</dl>


<p>
The instantiation function contains at least the 3 following steps :
<ul>
<li>define the size of the objects of the class, the number of inlets and the number
of outlets. This is done by the <code>fts_class_init</code> function.
<li>define the methods using the function <code>fts_method_define</code> previously described
<li>define the types of the outlets using the function <code>fts_outlet_type_define</code> previously
 described
</ul>

<p>
The instantiation function can should return <code>fts_Success</code> if
the class has been instantiate correctly, or
<code>fts_CannotInstantiate</code> in case of errors.


<a name="The fts_class_init Function"><h3>The <code>fts_class_init</code> Function</h3></a>


<code>fts_status_t fts_class_init( fts_class_t *<i>class</i>, unsigned int <i>size</i>, int <i>ninlets</i>, int <i>noutlets</i>, void *<i>user_data</i>)</code> <p>

<p>
The arguments of <code>fts_class_init</code> have the following meaning :
<dl>
<dt> <i> class</i> <dd> 
the class which is being initialized
<dt> <i> size</i> <dd> 
the size of the objects of the class. It is the <code>sizeof</code> of the object
structure
<dt> <i> ninlets</i> <dd> 
the number of inlets of the objects of the class
<dt> <i> noutlets</i> <dd> 
the number of outlets of the objects of the class
<dt> <i> user_data</i> <dd> 
this argument will be simply stored in the fts_class_t structure, giving
a simple way to share datas between all the objects of a class
</dl>

<a name="Class Instantiation Function Example"><h3>Class Instantiation Function Example</h3></a>

<p>
Below is the example of the instantiation function of the <code>integer</code> object
already defined. This instantiation function first initialize the class, then
defines all the methods of the class, then defines the type of the outlet.
The objects of this class have 2 inlets and 1 outlet :

<ul>
<li>the inlet 0 accepts 2 messages with selectors "bang" and "int"
<li>the inlet 1 accepts 1 message with selector "int"
<li>the outlet sends message with selector "int"
</ul>

<pre>
fts_status_t integer_instantiate( fts_class_t *class, int ac, fts_atom_t *at)
{
  fts_type_t t[2];

  fts_class_init( class, sizeof( integer_t), 2, 1, 0);

  t[0] = fts_t_symbol;
  t[1] = fts_t_int;
  /* init method */
  fts_method_define( class, fts_SystemInlet, fts_s_init, integer_init, 2, t);

  t[0] = fts_t_int;
  /* message "int" on inlet 0 method */
  fts_method_define( class, 0, fts_type_get_selector( fts_t_int), integer_int, 1, t);

  /* message "int" on inlet 1 method */
  fts_method_define( class, 1, fts_type_get_selector( fts_t_int), integer_in1, 1, t);

  /* message "bang" on inlet 0 method */
  fts_method_define( class, 0, fts_s_bang, integer_bang, 0, 0);

  /* outlet type is int */
  fts_outlet_type_define(class, 0, fts_type_get_selector( fts_t_int), 1, t);

  return fts_Success;
}
</pre>



<!-- ---------------------------------------------------------------------- -->
<p>
<hr>
<a name="Metaclasses"><h2>Metaclasses</h2></a>


<p>
A metaclass is a definition of a set of classes having common behavior and
sharing the same <i>instantiation function</i>.
To a metaclass is associated a base of already instantiated classes.
A class is instantiated when an object is created, following the
<i>metaclass instantiation</i> process described bellow.


<p>
<ul>
<li> <a href="#Metaclass Instantiation Process">Metaclass Instantiation Process </a>
<li> <a href="#Equivalence Functions">Equivalence Functions</a>
<li> <a href="#Existing Equivalence Functions">Existing Equivalence Functions</a>
<li> <a href="#Example of Equivalence Function">Example of Equivalence Function</a>
<li> <a href="#Metaclasses Installation">Metaclasses Installation</a>
</ul>


<a name="Metaclass Instantiation Process"><h3>Metaclass Instantiation Process</h3></a>

<p>
The metaclass instantiation process is based on the following assumption : the decision that
2 objects are in the same class can be made by comparing the objects creation arguments <i>only</i>.

<p>
A metaclass is <i>instantiated</i> on demand, when an object is created,
through the following steps :
<ul>
<li>the base of classes of the metaclass is searched for a candidate class by 
a matching based on the creation arguments of the object. This matching uses
the <i>equivalence function</i>, with the following algorithm :
<pre>
for all classes of the base
 {
   if ( equivalence_function( creation_arguments( current_class), 
                              creation_arguments( object_to_be_created))
     {
       /* object to be created is of the current class */

       return current_class;
     }
 }
</pre>
<li>if no match is found, a class is instantiated : the class instantiation function
is called, its arguments being the object creation arguments. This class is stored in
the base of classes of the meta-class together with the creation arguments of the object,
for later use by the equivalence function.
<li>memory is allocated for the object
<li>if defined, the <code>$init</code> method is called for this object
</ul>


<a name="Equivalence Functions"><h3>Equivalence Functions</h3></a>

<p>
The equivalence function is used by the message system at object creation time.
It is used to decide if 2 objects are in the same class or not.

<code>int a_equivalence_function( int <i>ac0</i>, const fts_atom_t *<i>at0</i>, int <i>ac1</i>, const fts_atom_t *<i>at1</i>)</code> <p>

<p>
The arguments of a <code>equivalence_function</code> have the following meaning :
<dl>
<dt> <i> ac0, ac1</i> <dd> 
the number of atoms in array <i>at0</i>, <i>at1</i>
<dt> <i> at0, at1</i> <dd> 
the arrays of arguments, one being the creation arguments of object being created,
the other being the creation arguments of the class in the class base
</dl>

<p>
The equivalence function should return true if the two set of arguments can correspond
to the same instance class, i.e. if they are equivalent with respect to the class
system.


<a name="Existing Equivalence Functions"><h3>Existing Equivalence Functions</h3></a>


<p>
The message system already provides a number of widely used equivalence functions. These
functions are described in the table below.
<dl>
 <dt> <i> fts_arg_equiv</i> 
  <dd> 
   return true (i.e. not zero) if the arguments are identical (same number, same types, same values).

 <dt> <i> fts_arg_type_equiv</i> 
  <dd> 
   return true (i.e. not zero) if the numbers and the types of the arguments are the same.

 <dt> <i> fts_first_arg_equiv</i> 
  <dd> 
   return true (i.e. not zero) if the first arguments are identical.

 <dt> <i> fts_narg_equiv</i>
  <dd> 
   return true (i.e. not zero) if the numbers of arguments are the same.

  <dt> <i> fts_never_equiv</i> 
   <dd> 
    Always return false  (i.e.zero). Using this equivalence function means that there will be 
    a new class instantiated for each object instantiated. This is useful as a first "coarse"
    implementation of a metaclass.
</dl>


<a name="Example of Equivalence Function"><h3>Example of Equivalence Function</h3></a>
 
<p>
Below is the example of the <code>bangbang</code> class : the <code>bangbang</code> object has 1 inlet, 
receiving
a bang, and a certain number of outlets. The number of outlets is given by the creation
argument, which is of type int. When receiving a <code>bang</code> message on its inlet,
the <code>bangbang</code> object outputs a <code>bang</code> message on all its outlets, starting
from the last.

<p>
The <code>bangbang</code> class is a metaclass, with a simple equivalence function : it
simply compares the identity of the arguments, which must be of type int.

<pre>
static int bangbang_equiv( int ac0, const fts_atom_t *at0,
                  int ac1, const fts_atom_t *at1)
{
  if (ac0 == 1 && ac1 == 1 
      && fts_is_int(at0) && fts_is_int(at1)
      && fts_get_int(at0) == fts_get_int(at1))
    return 1;
  else
    return 0;
}
</pre>

<pre>
typedef struct {
  fts_object_t o;
  int noutlets;
} bangbang_t;

static void bangbang_bang( fts_object_t *object, int winlet, fts_symbol_t selector,
               int ac, const fts_atom_t *at)
{
  bangbang_t *this;
  int i;

  this = (bangbang_t *)object;
  for (i = this->noutlets-1; i >= 0; i--)
    fts_outlet_send(object, i, fts_s_bang, 0, 0);
}

static void bangbang_init( fts_object_t *object, int winlet, fts_symbol_t selector,
               int ac, const fts_atom_t *at)
{
  bangbang_t *this;

  this->noutlets = fts_get_int_arg( ac, at, 1, 2);
}

static fts_status_t bangbang_instantiate(fts_class_t *class, int ac, const fts_atom_t *at)
{
  int i, noutlets;
  fts_symbol_t t[2];

  if ((ac >= 1)  && fts_is_int( at))
    noutlets = fts_get_int(at);
  else
    noutlets = 1;

  fts_class_init(class, sizeof(bangbang_t), 1, noutlets, 0);

  fts_method_define(class, 0, fts_s_bang, bangbang_bang, 0, 0);

  t[0] = fts_t_symbol;
  t[1] = fts_t_int;
  fts_method_define( class, fts_SystemInlet, fts_s_init, bangbang_init, 2, &a);

  for (i = 0; i < noutlets; i++)
    fts_outlet_type_define( class, i, fts_s_bang, 0, 0);

  return fts_Success;
}
</pre>


<a name="Metaclasses Installation"><h3>Metaclasses Installation</h3></a>

<p>
A metaclass is installed with the following function:<br>
<code>fts_metaclass_t *fts_metaclass_create(fts_symbol_t <i>name</i>, fts_instantiate_fun_t <i>instantiate_function</i>, fts_equiv_fun_t <i>equiv_function</i>)</code>

<p>
The metaclass is named <i>name</i>; </i>instantiate_function</i> will be used
to instantiate new classes, and <i>equiv_function</i> will be its equivalence
function.

<p>
As for classes, metaclasses can be aliased, using the <code>fts_metaclass_alias</code>
function: <br>
<code>void fts_metaclass_alias( fts_symbol_t <i>new_name</i>, fts_symbol_t <i>old_name</i>) </code> <br>
This function has the same behavior as <code>fts_class_alias</code>.

<p>
Below is an example of a metaclass installation:
<pre>
void bangbang_config(void)
{
  /* Install the metaclass "bangbang" */
  fts_metaclass_install( fts_new_symbol("bangbang"), bangbang_instantiate, bangbang_equiv);

  /* Register "bb" to be an alias for "bangbang" */
  fts_metaclass_alias( fts_new_symbol("bb"), fts_new_symbol("bangbang"));
}
</pre>


<!-- ---------------------------------------------------------------------- -->
<p>
<hr>
<a name="Object And Class Properties"><h2>Object And Class Properties</h2></a>

<p>
In FTS each object and class can have properties associated with it;
a property is simply a pair name value, where the name is an FTS symbol,
and the value is any FTS value; a property is a kind of dynamic storage
tied to the object; a class can provide default values for properties,
that are valid for all the object instance of the class.

<p>
Also, the property system is extended with standard AI like constraint
propagation and daemon techniques: putting a property or getting a property
from an object can transparently activate a  number of functions that
propagate the properties in the object network.

<p>
This subsystem is currently used in FTS to implement some experimental
optimization and features in the DSP compiler.

<p>
Its API is not currently documented.


<!-- ---------------------------------------------------------------------- -->
<p>
<hr>
<a name="Examples"><h2>Examples</h2></a>

<a href="../../packages/sources/c/src/integer.c">Source of the <code>integer</code> object</a>
<p>

<a href="../../packages/sources/c/src/bangbang.c">Source of the <code>bangbang</code> object</a>
<p>



<!-- ---------------------------------------------------------------------- -->

</table>

<hr noshade size=1>

<p>
Copyright &copy; 1995,1999 <a href="http://www.ircam.fr/">IRCAM</a>.

</body>
</html>
