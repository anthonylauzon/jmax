<html>

<!--                                                                    -->
<!-- jMax                                                               -->
<!--                                                                    -->
<!-- Copyright (C) 1999 by IRCAM                                        -->
<!-- All rights reserved.                                               -->
<!--                                                                    -->
<!-- This program may be used and distributed under the terms of the    -->
<!-- accompanying LICENSE.                                              -->
<!--                                                                    -->
<!-- This program is distributed WITHOUT ANY WARRANTY. See the LICENSE  -->
<!-- for DISCLAIMER OF WARRANTY.                                        -->
<!--                                                                    -->

<head>
<title>jMax Documentation - Control Objects Developer's Guide</title>
</head>
     
<body text="#000000" bgcolor="#cccccc">

<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0>
<TR>
  <TD ALIGN=LEFT>
    <A HREF="http://www.ircam.fr/jmax/"><IMG SRC="../../images/jmax_logo_tiny.gif" BORDER=0 ALT="jMax"></A>
  </TD>
  <TD ALIGN=RIGHT>
    <A HREF="http://www.ircam.fr/"><IMG SRC="../../images/ircam_banner.gif" BORDER=0 ALT="IRCAM - Centre Georges Pompidou"></A>
  </TD>
</TR>
</TABLE>
<BR>

<p>
<UL TYPE=SQUARE>
  <LI><A HREF=../index.html>Documentation</A>
  <UL TYPE=SQUARE>
    <LI><A HREF=index.html>Developer Documentation</A>
  </UL>
</UL>

<p>
<font size=+3 color=#FFFFFF><b>Control Objects Developer's Guide</b></font>

<p>
<hr noshade size=1>
<ul type=dot>
  <li><a href="#disclaimer">Disclaimer</A>
  <li> <a href="#Introduction">Introduction</a>
  <li> <a href="#Objects">Objects</a>
  <li> <a href="#Methods">Methods</a>
  <li> <a href="#Message Sending">Message Sending</a>
  <li> <a href="#Messages and Methods">Messages and Methods</a>
  <li> <a href="#System Methods">System Methods</a>
  <li> <a href="#Outlet Typing">Outlet Typing</a>
  <li> <a href="#Classes">Classes</a>
  <li> <a href="#Metaclasses and Class Instantiation">Metaclasses and Class Instantiation</a>
  <li> <a href="#Metaclasses Creation and Installation">Metaclasses Creation and Installation</a>
  <li> <a href="#Complete Examples">Complete Examples</a>
  <li> <a href="#Generic Metaclasses">Generic Metaclasses</a>
  <li> <a href="#Object And Class Properties">Object And Class Properties</a>
</ul>

<p>
<hr noshade size=1>

<TABLE WIDTH=100% BORDER=0 CELLSPACING=1 CELLPADDING=20 BGCOLOR=#FFFFFF>
<TR><TD>


<a name="disclaimer"> <H2> Disclaimer </H2> </a>

<p>
The API presented here is subject to small changes.

<p>
This first version of the documentation is adapted from the <quote>FTS Message System 
Programming Guide</quote> and some inconsistancies may subsist.


<!-- ---------------------------------------------------------------------- -->
<p>
<hr>
<a name="Introduction"><h2>Introduction</h2></a>

<p>
This documentation introduces the jMax objects API, known in Max-Opcode as the <i>"external"</i>
objects API. As a consequence of the client/server architecture of jMax, these objects are
loaded and executes in the jMax server, called FTS. The documentation will then use the 
term <i>FTS message system</i> to denote the server objects API.

<p>
The FTS message system combines an object system and a message passing
system. It is a new definition of Max/FTS message system already implemented
in Max/Macintosh and in previous versions of Max/FTS on the ISPW.

<p>
The main concepts of FTS message system are:
<ul>
<li> <i>objects</i> : a FTS object is a <i>state</i> (some memory holding values)
and a set of <i>connections</i> used for message sending between objects
<li> <i>messages</i> : a FTS message is a <i>selector</i> (a symbol) and a list
of arguments which are <i>atoms</i>
<li> <i>inlets</i> and <i>outlets</i> :to each object is associated a set of receptors, the 
inlets and a set of emitters, the outlets. An inlet receives messages and messages can be emitted
on outlets
<li> <i>methods</i> : the reception of a message on an inlet trigs the call of a method. A FTS
method is a C function with a particular signature
<li> <i>classes</i> : a FTS class is a set of objects having a common <i>interface</i>
regarding the object model
<li> <i>metaclasses</i> : a FTS metaclass is a set of classes sharing common behaviour
</ul>


<!-- ---------------------------------------------------------------------- -->
<p>
<hr>
<a name="Objects"><h2>Objects</h2></a>

<p>
A FTS object is an abstraction that store information and 
can receive and emit messages. To an object is allocated some
memory storing its <i>state</i> as a C structure.

<pre>
typedef struct {
  fts_object_t o;   /* MUST BE FIRST STRUCTURE MEMBER */
  long n;           /* the state of a integer object */
} integer_t;
</pre>

<p>
<strong>Attention !!!</strong> A FTS object must always have a first structure member
of type <code>fts_object_t</code>. This implements in C the fact that all FTS objects
inherits from the <code>fts_object_t</code> type.

<p>
The only "system" member of the structure which is made mandatory by the FTS object
 system is the first member of type <code>fts_object_t</code>. The other members of the structure 
are "user" members and are not handled by the system.

<p>
An number of functions or macros are provided to get some of the object
characteristic:

<pre>
int  
fts_object_get_outlets_number(fts_object_t *<i>obj</i>);
</pre>

Return the number of outlets the object <i>obj</i> have.

<pre>
fts_symbol_t fts_object_get_outlet_type(fts_object_t *<i>obj</i>, int <i>outlet</i>);
</pre>

<p>
Return the type of the outlet <i>outlet</i> for <i>obj</i> (see
<a href="#Outlet Typing">Outlet Typing</a>).

<pre>
int  
fts_object_get_inlets_number(fts_object_t *<i>obj</i>);
</pre>

Return the number of inlets the object <i>obj</i> have.

<pre>
const char *fts_object_get_class_name(fts_object_t *<i>obj</i>);
</pre>

Return as a C string the name of the object class; to be used
only for user messages.



<!-- ---------------------------------------------------------------------- -->
<p>
<hr>
<a name="Methods"><h2>Methods</h2></a>

<p>
A <i>method</i> is a C-function that will be called when an object receives
a message on one of its inlets. It has a standard signature, and all the
methods access their arguments the same way.

<ul>
<li> <a href="#Method Signature">Method Signature</a>
<li> <a href="#Method Arguments">Method Arguments</a>
<li> <a href="#Accessing Arguments">Accessing Arguments</a>
<li> <a href="#List of Access Macros">List of Access Macros</a>
</ul>


<a name="Method Signature"><h3>Method Signature</h3></a>

<p>
All FTS methods have the same <i>signature</i>, i.e. the same number of arguments
of the same types. This signature is the following :

<code>void method( fts_object_t *<i>object</i>, int <i>winlet</i>, fts_symbol_t <i>selector</i>, int <i>ac</i>,  const fts_atom_t *<i>at</i>)</code> <p>

<p>
The arguments of the method have the following meaning :
<dl>
<dt> <i> object</i> <dd> 
a pointer to the object receiving the message
<dt> <i> winlet</i> <dd> 
the number of the inlet on which message was received
<dt> <i> selector</i> <dd> 
the message selector, a symbol. The <code>fts_symbol_t</code>
data structure is discussed in details in <a href="../Kernel_Reference_Manual/Kernel_Reference_Manual.html">FTS Kernel Reference Manual</a>.
<dt> <i> ac</i> <dd> 
the number of arguments
<dt> <i> at</i> <dd> 
the arguments array
</dl>


<a name="Method Arguments"><h3>Method Arguments</h3></a>

<p>
The arguments of a method are of type <code>fts_atom_t</code>. The <code>fts_atom_t</code>
data structure is discussed in details in <a href="http:../Kernel_Reference_Manual/Kernel_Reference_Manual.html">FTS Kernel Reference Manual</a>.

<p>
<b>Attention !!!</b> The arguments are passed by the message system as an 
array of <b>constant</b> atoms.
This means that a method cannot modify its arguments. Modifying the arguments
of a method in the body of the method can lead to unpredictable side effects.
If this is needed for convenience, the arguments must first be <i>copied</i>.


<a name="Accessing Arguments"><h3>Accessing Arguments</h3></a>

<p>
A method access its arguments via <i>access macros</i>, which handle both 
accessing the atoms and giving a default value if corresponding 
argument is optional.

<p>
<b>Attention !!!</b> It is strongly recommended to use the arguments access
macros. Accessing directly the members of the <code>fts_atom_t</code> structure
is garanteed not to work across different releases of FTS, because <code>fts_atom_t</code>
implementation may change.

<p>
This is an example of a simple method, taking one argument of type <code>long</code>,
with a default value of 0, which stores the value of this argument in the state
of the object :

<pre>
void integer_in1( fts_object_t *object, int winlet, fts_symbol_t selector, 
                  int ac, const fts_atom_t *at)
{
  integer_t *this = (integer_t *)object;

  this->n = fts_get_int_arg( ac, at, 0, 0);
}
</pre>

<p>
In this method, the <i>object</i> argument, typed as an <code>fts_object_t *</code>
is in fact a pointer to an object of type <code>integer_t</code> (defined earlier),
which first 
structure member is of type <code>fts_object_t</code>. This explains the cast
made at beginning of method.


<a name="List of Access Macros"><h3>List of Access Macros</h3></a>

<p>
Below is the list of available access macros :
<dl>
<dt> <code> fts_get_int_arg( <i>AC</i>, <i>AT</i>, <i>N</i>, <i>DEFAULT</i>)</code> <dd> 
gets an argument of type <code>int</code>
<dt> <code> fts_get_float_arg( <i>AC</i>, <i>AT</i>, <i>N</i>, <i>DEFAULT</i>)</code> <dd> 
gets an argument of type <code>float</code>
<dt> <code> fts_get_symbol_arg( <i>AC</i>, <i>AT</i>, <i>N</i>, <i>DEFAULT</i>)</code> <dd> 
gets an argument of type <code>fts_symbol_t</code>
<dt> <code> fts_get_string_arg( <i>AC</i>, <i>AT</i>, <i>N</i>, <i>DEFAULT</i>)</code> <dd> 
gets an argument of type <code>const char *</code>
<dt> <code> fts_get_obj_arg( <i>AC</i>, <i>AT</i>, <i>N</i>, <i>DEFAULT</i>)</code> <dd> 
gets an argument of type <code>void *</code>
</dl>

<p>
The macro arguments have the following meaning :
<dl>
<dt> <i> AC</i> <dd> 
the number of atoms in array <i>AT</i>
<dt> <i> AT</i> <dd> 
the atom array
<dt> <i> N</i> <dd> 
the index of the requested argument
<dt> <i> DEFAULT</i> <dd> 
the default value for the requested argument
</dl>

<p>
All these macros have the same semantic : if <i>N</i> is less than <i>AC</i>,
return the value of atom <i>N</i> in array <i>AT</i>, else return value <i>DEFAULT</i>.


<!-- ---------------------------------------------------------------------- -->
<p>
<hr>
<a name="Message Sending"><h2>Message Sending</h2></a>
 
<p>
Messages can be send on the outlets of an object, using the
<code>fts_outlet_send</code> function.

<ul>
<li> <a href="#The fts_outlet_send Function">The <code>fts_outlet_send</code> Function</a>
<li> <a href="#Message Sending Example">Message Sending Example</a>
<li> <a href="#Message Arguments Building">Message Arguments Building</a>
<li> <a href="#Message Selectors">Message Selectors</a>
<li> <a href="#Shortcuts for bang, int, float and symbol Messages">Shortcuts for <code>bang</code>, <code>int</code>, <code>float</code> and <code>symbol</code> Messages</a>
</ul>


<a name="The fts_outlet_send Function"><h3>The <code>fts_outlet_send</code> Function</h3></a>

<p>
<code>fts_status_t  fts_outlet_send( fts_object_t *<i>object</i>, int <i>woutlet</i>, fts_symbol_t <i>selector</i>, int <i>argc</i>, const fts_atom_t *<i>args</i>) </code>

<p>
The arguments of <code>fts_outlet_send</code> have the following meaning :
<dl>
<dt> <i> object</i> <dd> 
the object from which outlet the message is send
<dt> <i> woutlet</i> <dd> 
the number of the outlet on which the message is send
<dt> <i> selector</i> <dd> 
the message selector, a symbol 
<dt> <i> argc</i> <dd> 
the count of arguments of the message
<dt> <i> args</i> <dd> 
the arguments of the message, an array of atoms
</dl>


<a name="Message Sending Example"><h3>Message Sending Example</h3></a>

<p>
Message sending is most of the time done in the body of a method, as in the following
example, a method sending on the outlet the content of the state of the object :
<pre>
void integer_bang( fts_object_t *object, int winlet, fts_symbol_t selector,
                   int ac, const fts_atom_t *at)
{
  integer_t *this = (integer_t *)object;
  fts_atom_t a;

  fts_set_int( &a, this->n);
  fts_outlet_send( object, 0, fts_s_int, 1, &a);
}
</pre>


<a name="Message Arguments Building"><h3>Message Arguments Building</h3></a>

<p>
Typically, sending a message is done in 2 phases :
<ul>
<li>format the arguments in an array of atoms. This is done using
the <code>fts_atom_t</code> data structure access macros
<li>call the <code>fts_outlet_send</code> function, passing it the arguments
array
</ul>

<p>
<b>Attention !!!</b> It is strongly recommended to use the atoms setting
macros to format the arguments. Accessing directly the members of the <code>fts_atom_t</code> structure
is garanteed not to work across different releases of FTS, because <code>fts_atom_t</code>
implementation may change.


<a name="Message Selectors"><h3>Message Selectors</h3></a>
 
<p>
A message selector is a <code>fts_symbol_t</code>. The <code>fts_symbol_t</code> 
data structure is not documented yet.
 
<p>
There is a number of predefined selectors which are defined in the header 
files for the message system. Below is the list of already defined selectors:
<dl>
<dt> <code> fts_s_int </code> <dd> 
"int"
<dt> <code> fts_s_float</code> <dd> 
"float"
<dt> <code> fts_s_bang</code> <dd> 
"bang"
<dt> <code> fts_s_list</code> <dd> 
"list"
<dt> <code> fts_s_symbol</code> <dd> 
"symbol"
<dt> <code> fts_s_set</code> <dd> 
"set"
<dt> <code> fts_s_sig</code> <dd> 
"sig"
<dt> <code> fts_s_put</code> <dd> 
"put"
</dl>
 
<p>
If a selector which is not already defined is
needed, the <code>fts_new_symbol</code> or <code>fts_new_symbol_copy</code>
functions generates a new symbol:
<ul>
<li>fts_symbol_t <code>fts_new_symbol( const char *s)</code> returns a new symbol
containing string s. <strong>Note:</strong> the passed string is not copied.
<li>fts_symbol_t <code>fts_new_symbol_copy( const char *s)</code> returns a new symbol
containing string s. <strong>Note:</strong> the passed string is copied. This function
is used when the passed string is not a constant.
</ul>


<a name="Shortcuts for bang, int, float and symbol Messages"><h3>Shortcuts for <code>bang</code>, <code>int</code>, <code>float</code> and <code>symbol</code> Messages</h3></a>

<p>
As sending <code>bang</code>, <code>int</code>, <code>float</code> and <code>symbol</code> messages is
very frequent, a number of shorcuts have been defined:
<ul>
<li> <code>fts_outlet_bang( fts_object_t *<i>object</i>, int <i>woutlet</i>)</code>
<li> <code>fts_outlet_int( fts_object_t *<i>object</i>, int <i>woutlet</i>, int <i>value</i>)</code>
<li> <code>fts_outlet_float( fts_object_t *<i>object</i>, int <i>woutlet</i>, float <i>value</i>)</code>
<li> <code>fts_outlet_symbol( fts_object_t *<i>object</i>, int <i>woutlet</i>, fts_symbol_t <i>value</i>)</code>
</ul>

<p>
There shortcuts are just wrappers that format a message with a single argument
and call <code>fts_outlet_send</code>.

<p>
The previous example of the <code>integer_bang</code> method can then be
written the following way, which is preferred:
<pre>
void integer_bang( fts_object_t *object, int winlet, fts_symbol_t selector,
                   int ac, const fts_atom_t *at)
{
  integer_t *this = (integer_t *)object;

  fts_outlet_int( object, 0, this->n);
}
</pre>


<!-- ---------------------------------------------------------------------- -->
<p>
<hr>
<a name="Messages and Methods"><h2>Messages and Methods</h2></a>

<p>
Method definition is done using the <code>fts_method_define</code> function, 
which is usually called when initializing the class. This function defines
to which message the method will be associated, and which kind of
arguments it expects.

<ul>
<li> <a href="#The fts_method_define Function">The <code>fts_method_define</code> Function</a>
<li> <a href="#Method Definition Example">Method Definition Example</a>
<li> <a href="#Method Arguments Types">Method Arguments Types</a>
<li> <a href="#Methods with Variable Arguments Number">Methods with Variable Arguments Number</a>
</ul>

<a name="The fts_method_define Function"><h3>The <code>fts_method_define</code> Function</h3></a>

<code>fts_status_t fts_method_define( fts_class_t *<i>class</i>, int <i>winlet</i>, fts_symbol_t <i>selector</i>, fts_method_t <i>method</i>, int <i>argc</i>, fts_symbol_t *<i>argtypes</i> )</code> <p>

<p>
The arguments of <code>fts_method_define</code> have the following meaning :
<dl>
<dt> <i> class</i> <dd> 
the class in which the definition is valid
<dt> <i> winlet</i> <dd> 
the number of the inlet for which the definition is valid
<dt> <i> selector</i> <dd> 
the associated message selector : when receiving a message having this
selector, the method will be called with the message arguments, after 
arguments type checking
<dt> <i> method</i> <dd> 
the method : a function having the signature already defined
<dt> <i> argc</i> <dd> 
the count of expected arguments
<dt> <i> argtypes</i> <dd> 
the types of expected arguments : the type checking mechanism will be detailled 
later
</dl>


<a name="Method Definition Example"><h3>Method Definition Example</h3></a>


<p>
Below is an example showing the installation of the method <code>integer_in1</code>
already defined for the <code>integer</code> object. This method is defined for
inlet number 1 and takes one argument of type <code>int</code>.

<pre>
fts_status_t integer_instantiate( fts_class_t *class, int ac, fts_atom_t *at)
{
  fts_symbol_t a;

  a = fts_s_int;
  fts_method_define( class, 1, fts_s_int, integer_in1, 1, &a);
}
</pre>


<a name="Method Arguments Types"><h3>Method Arguments Types</h3></a>
 
<p>
When defining a method associated with a message, it is necessary to define 
the arguments types which are expected. This will be used by the system
to do a type checking, at connection-time and at run-time (with some
optimizations).


<p>
This type definition is done with 
the <i>argtypes</i> argument of function <code>fts_method_define</code>.
This argument is an array of elements of type <code>fts_symbol_t</code>,
each element being the name (as an <code>fts_symbol_t</code>) of the type.
Each element defines the expected type of the argument having
same index in the array of atoms which is the arguments of the 
received message.
        
<p>
The elements of the array <i>argtypes</i> can take the following values (or an bit-or
of some of them) :
<dl>
<dt> <code> fts_s_int</code> <dd> 
argument must be of type <code>int</code>, initialized with <code>fts_set_int</code>
<dt> <code> fts_s_float</code> <dd> 
argument must be of type <code>float</code>, initialized with <code>fts_set_float</code>
<dt> <code> fts_s_symbol</code> <dd> 
argument must be of type <code>symbol</code>, initialized with <code>fts_set_symbol</code>
<dt> <code> fts_s_string</code> <dd> 
argument must be of type <code>string</code>, initialized with <code>fts_set_string</code>
<dt> <code> fts_s_object</code> <dd> 
argument must be of type <code>object</code>, initialized with <code>fts_set_obj</code>
</dl>


<a name="Methods with Variable Arguments Number"><h3>Methods with Variable Arguments Number</h3></a>

<p>
A method accepting a variable number of arguments is defined using function 
<code>fts_method_define_optargs</code>.

<code>fts_status_t fts_method_define_optargs( fts_class_t *<i>class</i>, int <i>winlet</i>, fts_symbol_t <i>selector</i>, fts_method_t <i>method</i>, int <i>argc</i>, fts_symbol_t *<i>argtypes</i>, int <i>min_argc</i> )</code> <p>

<p>
The arguments of <code>fts_method_define_optargs</code> are similar to <code>fts_method_define</code>,
except for the last supplementary arguments:
<dl>
<dt> <i> min_argc</i> <dd> 
the minimum count of expected arguments
</dl>

<p>
Below is an example showing the installation of a method <code>integer_incr</code>
for the <code>integer</code> object. This method takes zero or one argument of type <code>int</code>.

<pre>

void integer_incr( fts_object_t *object, int winlet, fts_symbol_t selector, 
                  int ac, const fts_atom_t *at)
{
  integer_t *this = (integer_t *)object;
  int incr = fts_get_int_arg( ac, at, 0, 1);

  this->n += incr;
}

fts_status_t integer_instantiate( fts_class_t *class, int ac, fts_atom_t *at)
{
  fts_symbol_t a;

  a = fts_s_int;
  fts_method_define_optargs( class, 0, fts_new_symbol("incr"), integer_incr, 1, &a, 0);
}
</pre>


<!-- ---------------------------------------------------------------------- -->
<p>
<hr>
<a name="System Methods"><h2>System Methods</h2></a>

<p>
Some of the methods of a class can be "system" methods, handling
system level functions. These functions are now : object initialisation 
and deletion, objects connection and disconnection.


<p>
All the system methods are associated to messages received on the
<i>system inlet</i>, which is a symbolic constant defined by
the message system. Except this, system methods are strictly 
identical to standard methods.


<ul>
<li> <a href="#The init Method">The <code>init</code> Method</a>
<li> <a href="#The delete Method">The <code>delete</code> Method</a>
<li> <a href="#System Messages Selectors">System Messages Selectors</a>
</ul>


<a name="The init Method"><h3>The <code>init</code> Method</h3></a>

<p>
The init method handles the initialisation of an object, but doesn't need to handle
memory allocation. It is very similar to a C++ <i>constructor</i>. If it is defined,
it is called
automaticaly by the system when an object is created. 


<p>
The <code>init</code> method arguments, are the object creation arguments, including
the class name; i.e. using FTS with the standard Max editor, the arguments of the
init arguments are the content of the object box.
The declaration of the types of these so-called <i>creation</i> arguments must take 
into account this feature.

<p>
The selector of the <code>init</code> method is the predefined symbol <code>fts_s_init</code>.

<p>
Below is the example of the init method for the <code>integer</code> object
already defined. This method just initialize the state of the object
with the value of its argument.

<pre>
void integer_init( fts_object_t *object, int winlet, fts_symbol_t selector, 
                   int ac, const fts_atom_t *at)
{
  integer_t *this = (integer_t *)object;

  post( "initializing an object of class %s", fts_symbol_name(fts_get_symbol_arg( ac, at, 0, 0)));
  this->n = fts_get_int_arg( ac, at, 1, 0);
}
</pre>


<p>
This method is installed by the following code :
<pre>
fts_status_t integer_instantiate( fts_class_t *class, int ac, fts_atom_t *at)
{
  fts_symbol_t a[2];

  a[0] = fts_s_symbol;
  a[1] = fts_s_int;
  fts_method_define( class, fts_SystemInlet, fts_s_init, integer_init, 2, a);
}
</pre>



<a name="The delete Method"><h3>The <code>delete</code> Method</h3></a>

<p>
The delete method handles the destruction of an object, but doesn't need to handle
memory de-allocation. It is very similar to a C++ <i>destructor</i>. If it is defined,
it is called automatically by the system when an object is deleted, without arguments.

<p>
The selector of the <code>delete</code> method is the predefined symbol <code>fts_s_delete</code>.

<p>
A delete method can be installed for the <code>integer</code> object by the following code :

<pre>
fts_status_t integer_instantiate( fts_class_t *class, int ac, fts_atom_t *at)
{
  fts_method_define( class, fts_SystemInlet, fts_s_delete, integer_delete, 
                     0, 0);
}
</pre>




<!-- ---------------------------------------------------------------------- -->
<p>
<hr>
<a name="Outlet Typing"><h2>Outlet Typing</h2></a>


<p>
The outlets of an object can be statically <i>typed</i>. If an outlet
is going to send only one kind of message selector, this selector and
the types of associated arguments can be declared using the <code>fts_outlet_type_define</code>
function.

<ul>
<li> <a href="#The fts_outlet_type_define Function">The <code>fts_outlet_type_define</code> Function</a>
<li> <a href="#Outlet Typing Example">Outlet Typing Example</a>
</ul>


<a name="The fts_outlet_type_define Function"><h3>The <code>fts_outlet_type_define</code> Function</h3></a>


<code>fts_status_t fts_outlet_type_define( fts_class_t *<i>class</i>, int <i>woutlet</i>, fts_symbol_t <i>selector</i>,int <i>argc</i>, fts_symbol_t *<i>argtypes</i>)</code> <p>

<p>
The arguments of <code>fts_outlet_type_define</code> have the following meaning :
<dl>
<dt> <i> class</i> <dd> 
the class for which the type is defined
<dt> <i> woutlet</i> <dd> 
the number of the outlet for which the type is defined
<dt> <i> selector</i> <dd> 
the associated message selector
<dt> <i> argc</i> <dd> 
the count of arguments
<dt> <i> argtypes</i> <dd> 
the types of message arguments
</dl>

<p>
The types of message arguments are the same as for function <code>fts_method_define</code>.
 

<p>
The type of an outlet will be used by the system
to do a type checking, at connection-time and at run-time (when needed).

<p>
Outlet typing do not affect the efficency of method calling; the method dispatching
use a entry dynamic cache that optimize methods calls for all objects,
not only statically type ones.

<p>
The type of an outlet is <i>unique</i> : 
if an outlet is supposed to send different kinds of messages, then
it must <i>not</i> be typed; this means that the symbol <code>fts_s_anything</code>
is not accepted as argument to this function.


<a name="Outlet Typing Example"><h3>Outlet Typing Example</h3></a>

<p>
The following code defines the type of the outlet for the <code>integer</code>
object. The outlet number 1 is defined to send only one type of message,
with selector <code>int</code> and one argument of type <code>int</code>.

<pre>
fts_status_t integer_instantiate( fts_class_t *class, int ac, fts_atom_t *at)
{
  fts_symbol_t a;

  a = fts_s_int;
  fts_outlet_type_define(class, 0, fts_s_int, 1, &a);
}
</pre>


<!-- ---------------------------------------------------------------------- -->
<p>
<hr>
<a name="Classes"><h2>Classes</h2></a>


<p>
The definition of a class is the definition of :
<ul>
<li>the size of the objects of the class
<li>the number of inlets of the objects of the class
<li>the number of outlets of the objects of the class
<li>for each inlet, a list of (message selectors, associated method, arguments types)
<li>for each outlet, the eventual message selector and arguments types
</ul>

<p>
It comes from this definition that all objects of a class have <i>same</i>
number of inlets and outlets. The mechanism for having variable number of inlets
and outlets is the <i>metaclass</i> described below.


<p>
The function that defines a class is called the <i>instantiation function</i>. 


<ul>
<li> <a href="#The Class Instantiation Function">The Class Instantiation Function</a>
<li> <a href="#The fts_class_init Function">The <code>fts_class_init</code> Function</a>
<li> <a href="#Class Instantiation Function Example">Class Instantiation Function Example</a>
</ul>


<a name="The Class Instantiation Function"><h3>The Class Instantiation Function</h3></a>


<p>
The signature of a class instantiation function is the following :

<code>fts_status_t <i>my_class_instantiate</i>( fts_class_t *<i>class</i>, int <i>ac</i>, fts_atom_t *<i>at</i>)</code> <p>

<p>
The arguments of the class instantiation function have the following meaning :
<dl>
<dt> <i> class</i> <dd> 
the class that is to be defined
<dt> <i> ac</i> <dd> 
the number of arguments
<dt> <i> at</i> <dd> 
the arguments array. The contents of these arguments will be discussed in 
the Class Instantiation Process description.
</dl>


<p>
The instantiation function contains at least the 3 following steps :
<ul>
<li>define the size of the objects of the class, the number of inlets and the number
of outlets. This is done by the <code>fts_class_init</code> function.
<li>define the methods using the function <code>fts_method_define</code> previously described
<li>define the types of the outlets using the function <code>fts_outlet_type_define</code> previously
 described
</ul>


<a name="The fts_class_init Function"><h3>The <code>fts_class_init</code> Function</h3></a>


<code>fts_status_t fts_class_init( fts_class_t *<i>class</i>, unsigned int <i>size</i>, int <i>ninlets</i>, int <i>noutlets</i>, void *<i>user_data</i>)</code> <p>

<p>
The arguments of <code>fts_class_init</code> have the following meaning :
<dl>
<dt> <i> class</i> <dd> 
the class which is being initialized
<dt> <i> size</i> <dd> 
the size of the objects of the class. It is the <code>sizeof</code> of the object
structure
<dt> <i> ninlets</i> <dd> 
the number of inlets of the objects of the class
<dt> <i> noutlets</i> <dd> 
the number of outlets of the objects of the class
<dt> <i> user_data</i> <dd> 
this argument will be simply stored in the fts_class_t structure, giving
a simple way to share datas between all the objects of a class
</dl>

<a name="Class Instantiation Function Example"><h3>Class Instantiation Function Example</h3></a>

<p>
Below is the example of the instantiation function of the <code>integer</code> object
already defined. This instantiation function first initialize the class, then
defines all the methods of the class, then defines the type of the outlet.
The objects of this class have 2 inlets and 1 outlet :

<ul>
<li>the inlet 0 accepts 2 messages with selectors "bang" and "int"
<li>the inlet 1 accepts 1 message with selector "int"
<li>the outlet sends message with selector "int"
</ul>

<pre>
fts_status_t integer_instantiate( fts_class_t *class, int ac, fts_atom_t *at)
{
  fts_symbol_t a[2];

  fts_class_init( class, sizeof( integer_t), 2, 1, 0);

  a[0] = fts_s_symbol;
  a[1] = fts_s_int;
  /* init method */
  fts_method_define( class, fts_SystemInlet, fts_s_init, integer_init, 2, &a);

  a[0] = fts_s_int;
  /* message "int" on inlet 0 method */
  fts_method_define( class, 0, fts_s_int, integer_int, 1, &a);

  /* message "int" on inlet 1 method */
  fts_method_define( class, 1, fts_s_int, integer_in1, 1, &a);

  /* message "bang" on inlet 0 method */
  fts_method_define( class, 0, fts_s_bang, integer_bang, 0, 0);

  /* outlet type is int */
  fts_outlet_type_define(class, 0, fts_s_int, 1, &a);

  return fts_Success;
}
</pre>



<!-- ---------------------------------------------------------------------- -->
<p>
<hr>
<a name="Metaclasses and Class Instantiation"><h2>Metaclasses and Class Instantiation</h2></a>


<p>
A metaclass is a definition of a set of classes having common behaviour and
sharing the same <i>instantiation function</i>.
To a metaclass is associated a base of already instantiated classes.
A class is instantiated when an object is created, following the
<i>class instantiation</i> process which is described bellow.


<p>
<ul>
<li> <a href="#Class Instantiation Process">Class Instantiation Process </a>
<li> <a href="#Equivalence Functions">Equivalence Functions</a>
<li> <a href="#Existing Equivalence Functions">Existing Equivalence Functions</a>
<li> <a href="#Example of Equivalence Function">Example of Equivalence Function</a>
</ul>


<a name="Class Instantiation Process"><h3>Class Instantiation Process</h3></a>

<p>
The class instantiation process is based on the following assumption : the decision that
2 objects are in the same class can be made by comparing the objects creation arguments <i>only</i>.

<p>
A class is <i>instanciated</i> on demand, when an object is created,
through the following steps :
<ul>
<li>the base of classes of the metaclass is searched for a candidate class by 
a matching based on the creation arguments of the object. This matching uses
the <i>equivalence function</i>, with the following algorithm :
<pre>
for all classes of the base
 {
   if ( equivalence_function( creation_arguments( current_class), 
                              creation_arguments( object_to_be_created))
     {
       /* object to be created is of the current class */

       return current_class;
     }
 }
</pre>
<li>if no match is found, a class is instantiated : the class instantiation function
is called, its arguments being the object creation arguments. This class is stored in
the base of classes of the meta-class together with the creation arguments of the object,
for later use by the equivalence function.
<li>memory is allocated for the object
<li>if defined, the <code>$init</code> method is called for this object
</ul>


<a name="Equivalence Functions"><h3>Equivalence Functions</h3></a>

<p>
The equivalence function is used by the message system at object creation time.
It is used to decide if 2 objects are in the same class or not.

<code>int a_equivalence_function( int <i>ac0</i>, const fts_atom_t *<i>at0</i>, int <i>ac1</i>, const fts_atom_t *<i>at1</i>)</code> <p>

<p>
The arguments of a <code>equivalence_function</code> have the following meaning :
<dl>
<dt> <i> ac0, ac1</i> <dd> 
the number of atoms in array <i>at0</i>, <i>at1</i>
<dt> <i> at0, at1</i> <dd> 
the arrays of arguments, one being the creation arguments of object being created,
the other being the creation arguments of the class in the class base
</dl>

<p>
The equivalence function should return true if the two set of arguments can correspond
to the same instance class, i.e. if they are equivalent with respect to the class
system.


<a name="Existing Equivalence Functions"><h3>Existing Equivalence Functions</h3></a>


<p>
The message system already provides a number of widely used equivalence functions. These
functions are described in the table below.
<dl>
 <dt> <i> fts_arg_equiv</i> 
  <dd> 
   return true (i.e. not zero) if the arguments are identical (same number, same types, same values).

 <dt> <i> fts_arg_type_equiv</i> 
  <dd> 
   return true (i.e. not zero) if the numbers and the types of the arguments are the same.

 <dt> <i> fts_first_arg_equiv</i> 
  <dd> 
   return true (i.e. not zero) if the first arguments are identical.

 <dt> <i> fts_narg_equiv</i>
  <dd> 
   return true (i.e. not zero) if the numbers of arguments are the same.

  <dt> <i> fts_always_equiv</i>
    <dd> 
      Always return true (i.e. not zero). Using this equivalence function means that there will be
      only one class instanciated. This is the case for standard objects with fixed numbers of
      inlets and oulets.

  <dt> <i> fts_never_equiv</i> 
   <dd> 
    Always return false  (i.e.zero). Using this equivalence function means that there will be 
    a new class instanciated for each object instantiated. This is usefull as a first "coarse"
    implementation of a metaclass.
</dl>


<a name="Example of Equivalence Function"><h3>Example of Equivalence Function</h3></a>
 
<p>
Below is the example of the <code>bangbang</code> class : the <code>bangbang</code> object has 1 inlet, 
receiving
a bang, and a certain number of outlets. The number of outlets is given by the creation
argument, which is of type int. When receiving a <code>bang</code> message on its inlet,
the <code>bangbang</code> object outputs a <code>bang</code> message on all its outlets, starting
from the last.

<p>
The <code>bangbang</code> class is a metaclass, with a simple equivalence function : it
simply compares the identity of the arguments, which must be of type int.

<pre>
static int bangbang_equiv( int ac0, const fts_atom_t *at0,
                  int ac1, const fts_atom_t *at1)
{
  if (ac0 == 1 && ac1 == 1 
      && fts_is_int(at0) && fts_is_int(at1)
      && fts_get_int(at0) == fts_get_int(at1))
    return 1;
  else
    return 0;
}
</pre>

<pre>
typedef struct {
  fts_object_t o;
  int noutlets;
} bangbang_t;

static void bangbang_bang( fts_object_t *object, int winlet, fts_symbol_t selector,
               int ac, const fts_atom_t *at)
{
  bangbang_t *this;
  int i;

  this = (bangbang_t *)object;
  for (i = this->noutlets-1; i >= 0; i--)
    fts_outlet_send(object, i, fts_s_bang, 0, 0);
}

static void bangbang_init( fts_object_t *object, int winlet, fts_symbol_t selector,
               int ac, const fts_atom_t *at)
{
  bangbang_t *this;

  this->noutlets = fts_get_int_arg( ac, at, 1, 2);
}

static fts_status_t bangbang_instantiate(fts_class_t *class, int ac, const fts_atom_t *at)
{
  int i, noutlets;
  fts_symbol_t a[0];

  if ((ac >= 1)  && fts_is_int( at))
    noutlets = fts_get_int(at);
  else
    noutlets = 1;

  fts_class_init(class, sizeof(bangbang_t), 1, noutlets, 0);

  fts_method_define(class, 0, fts_s_bang, bangbang_bang, 0, 0);

  a[0] = fts_s_symbol;
  a[1] = fts_s_int;
  fts_method_define( class, fts_SystemInlet, fts_s_init, bangbang_init, 2, &a);

  for (i = 0; i < noutlets; i++)
    fts_outlet_type_define( class, i, fts_s_bang, 0, 0);

  return fts_Success;
}
</pre>



<!-- ---------------------------------------------------------------------- -->
<p>
<hr>
<a name="Metaclasses Creation and Installation"><h2>Metaclasses Creation and Installation</h2></a>

<p>
A metaclass is created with the following function:

<pre>
fts_metaclass_t *fts_metaclass_create(fts_symbol_t <i>name</i>,
		     fts_method_instantiate_t </i>instantiate_function</i>,
		     fts_method_equiv_t <i>equiv_function</i>);
</pre>

<p>
The metaclass is named <i>name</i>; </i>instantiate_function</i> will be used
to instantiate new classes, and <i>equiv_function</i> will be its equivalence
function.
Different metaclasses can have the same name; see <a href="#Generic Metaclasses">Generic Metaclasses</a>.

<p>
For simplicity, it can be convenient to have multiple names (usually
abbreviation) for the same kind of object; the standard way to do this
in FTS is to declare an alias to a name, with the following function:

<pre>
void
fts_metaclass_alias(fts_symbol_t <i>new_name</i>, fts_symbol_t <i>old_name</i>)
</pre>

<p>
After the call to <code>fts_metaclass_alias</code>, the name
<i>new_name</i>, when used as a metaclass name, will be always
automatically substituted by <i>old_name</i>.  Since more metaclasses
can have the same name, this is not equivalent to say that a
meta-class can have multiple names; i.e. all the metaclass with the
same name will share the same set of aliases.

<pre>
void
integer_config(void)
{
  /* create the class 'integer' */

  fts_metaclass_create(fts_new_symbol("int"),integer_instantiate, fts_always_equiv);

  /* ... and register 2 aliases for the "int" name: "i" and "integer" */

  fts_metaclass_alias(fts_new_symbol("integer"), fts_new_symbol("int"));
  fts_metaclass_alias(fts_new_symbol("i"), fts_new_symbol("int"));
}
</pre>

<hr> <a name="Complete Examples"><h2>Complete Examples</h2></a>

<a href="integer.c">Source of the <code>integer</code> object</a>
<p>

<a href="bangbang.c">Source of the <code>bangbang</code> object</a>
<p>




<!-- ---------------------------------------------------------------------- -->
<p>
<hr>
<a name="Generic Metaclasses"><h2>Generic Metaclasses</h2></a>


<p>
In some cases, objects with the same name correspond to behaviour that are
so different to sugger a completely distinct implementation; in other case,
a programmer would like to add a new behaviour to the same object name,
without modifing the existing implementation.

<p>
The FTS message system provide a way to view different metaclasses as
the implementation of a single metaclass, the generic metaclass.

<p>
The term "generic" derive from the generic programming technique; if
we see FTS objects as the operator and statements of a program
represented by the FTS patches, then a generic operator (in the object
oriented programming sense) can be implemented with a generic
metaclass; for example, the "+" operator on control message means
correspond to two actual operations depending on the argument being an
int or a float; so "+ 1" and "+ 1.0" correspond to two different
operations, but to the same, generic, operator.

<p>
Generic operators can be (and are, for object like "+") implemented
using generic metclasses.

<p>
The principle is the following: if more than one class with the same
name exists, the class instatiation algorithm explained in <a
href="#Metaclasses and Class Instantiation">Metaclasses and Class
Instantiation</a> is followed with the first class found; in case
of failure of the class instantiation function, i.e. in the case the 
class instantiation function do not return <code>fts_Success</code>,
the next metaclass with the same name is tryed, and so on.

<p>
If you design a metaclass so to be extensible or modularly integrable
in a generic metaclass, you should be carefull in testing the argument
in the instation function and to return an error in case the metaclass
cannot implement the requested class; FTS do not provide a declarative
method to discriminate between different metaclasses in order to leave
the most generic flexibility in generic metaclasses design; for example,
a metaclass can overide the behaviour of an existing metaclass for
a specific value of its argument, for example to provide an optimized
implementation of a specific special case.

<p>
The <code>fts_metaclass_create</code> function always add the new
metaclass at the end of the class list; in order to add a new
behaviour on top of an existing class, the
<code>fts_metaclass_create_override</code> function should be used;
this function behave exactly like <code>fts_metaclass_create</code>,
but add the new metaclass at the beginning of the list, so that it is
allowed to override the behaviour of existing classes.



<!-- ---------------------------------------------------------------------- -->
<p>
<hr>
<a name="Object And Class Properties"><h2>Object And Class Properties</h2></a>

<p>
In FTS each object and class can have properties associated with it;
a property is simply a pair name value, where the name is an FTS symbol,
and the value is any FTS value; a property is a kind of dynamic storage
tied to the object; a class can provide default values for properties,
that are valid for all the object instance of the class.

<p>
Also, the property system is extended with standard AI like constraint
progagation and daemon techniques: putting a property or getting a property
from an object can transparently activate a  number of functions that
propagate the properties in the object network.

<p>
This subsystem is currently used in FTS to implement some experimental
optimization and features in the DSP compiler.

<p>
Its API is not currently documented.

<!-- ---------------------------------------------------------------------- -->

</table>

<hr noshade size=1>

<p>
Copyright &copy; 1995,1999 <a href="http://www.ircam.fr/">IRCAM</a>.

</body>
</html>

