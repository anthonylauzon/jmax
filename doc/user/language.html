<HTML>
<HEAD>
<TITLE> The jMax Language </TITLE>
</HEAD>

<BODY TEXT="#000000" BGCOLOR="#CCCCCC" LINK="#000000" VLINK="#000000">

<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0>
<TR>
  <TD ALIGN=LEFT>
    <A HREF="http://www.ircam.fr/jmax/"><IMG SRC="../images/jmax_logo_tiny.gif" BORDER=0 ALT="jMax"></A>
  </TD>
  <TD ALIGN=RIGHT>
    <A HREF="http://www.ircam.fr/"><IMG SRC="../images/ircam_banner.gif" BORDER=0 ALT="IRCAM - Centre Georges Pompidou"></A>
  </TD>
</TR>
</TABLE>
<BR>

<UL TYPE=SQUARE>
  <LI><A HREF=../index.html>Documentation</A>
  <UL TYPE=SQUARE>
    <LI><A HREF=index.html>User Documentation</A>
  </UL>
</UL>

<FONT COLOR=#FFFFFF SIZE=+3><b>The Language</b></FONT>
<UL>
  <LI><A HREF="#jmaxvsmax"><I>j</I>Max is not Max</A>
  <LI><A HREF="#objects">Objects and Patchers</A>
  <LI><A HREF="#variables">Variables</A>
  <LI><A HREF="#expressions">Expressions</A>
  <LI><A HREF="#subpatchers">Subpatchers</A>
  <LI><A HREF="#templates">Templates</A>
  <LI><A HREF="#lexical">Lexical Conventions</A>
</UL>

<HR NOSHADE SIZE=1>
<TABLE WIDTH=100% BORDER=0 CELLSPACING=1 CELLPADDING=20 BGCOLOR=#FFFFFF>
<TR><TD>

<A NAME="jmaxvsmax">
<h2><I>j</I>Max is not Max</h2> </A>

<P>
<I>j</I>Max is based on the same programming paradigm as the other
members of the Max family, but it go a little bit further, and
introduce a first set of language extensions to augment its expressive
power, and to finally simplify the life of patch programmers, by
giving better ways to customize and parametrize patches and patch
libraries, and to refer data from objects.

<P>
This first release of <I>j</I>Max introduce the set of basic mechanisms;
these mechanisms will be used as the fundation for a new object library,
and will be extended in future releases.

<A NAME="objects">
<h2>Objects and Patchers</h2></A>

<p>
A <i>j</i>Max programm consists of objects, which appear in the context
of a patcher and can be connected via connections between their inlets 
and outlets in order to pass messages between each others.

<p>
In general the <i>j</i>Max represent different functionalities as well as
data structures or system resources (like i/o channels).

<p>
The patcher context helps to modulize <i>j</i>Max programms.
A patcher can have in- and outlets and can appear in form of a subpatcher 
or a template just like an object inside another patcher.

<A NAME="variables">
<h2>Variables</h2></A>

<P>
A variable is a name associated to a value. 
The association between a value and a name is made by instantiating an object, 
so the value of a variable do not change during the execution, but only as 
the result of an editing operation.

<P>
In order to be able to define a variable, an object need to export a
value, of any supported type; in general, not all the objects need or
should export a value, but only those objects representing some data
that need to be shared between objects; any objects can export data by
using a very simple API (not documented in this release); currently,
only the object <tt>const</tt>, an object without inlets and outlets, export
a value, that correspond to its first argument.

<P>
A variable can be declared by prepending the variable name followed
by a semicolon to the object description, like in <tt>sr : const 44100</tt>.

<P>
A variable value can be used in the instantiation of an object. 
An argument in the form <tt>$variable-name</tt> is substituted with the
variable value <STRONG>before</STRONG> the object is instantiated.
Since the variable substitution is handled by the system, the object
code don't need to know about variables, and all the object can be used
with variables.

<P>
<I>j</I>Max use local scoping for variables; this means that a variable
defined in a patcher will be visible in all its subpatchers, but it
will not be visible outside the patcher of definition; a patcher see all 
the variables defined in its parent and ancestor patchers.

<p>
The flexibility given by this scoping rule avoid conflicts and errors
in reusing variables names and simplify writing reusable patches.

<p>
Variables will be the preferred way to handle reference
to any kind of data in the future (like table and table~ objects), so that
locality of scoping will be available to all the form of data referencing.
In a future version, local variables will be accessible from the outside of
a patch by using a composite variable name (like <tt>$spat.input.level</tt>).

<P>
The system keep track of all the dependencies between variables, and automatically
update all the depending objects when a variable change value as an effect of an editing
operations; since variables can depend on variables, the dependency handling is recursive;
all the unresolved dependencies handled as instantiation errors
(<I>red objects</I>); the resolving of pending dependencies cause automatic
object reinstantiation.

<P>
A variable can also contains an array of values; an array can for example
be defined by the object <tt>rates: const {32000 44100 48000}</tt>, 
and accessed with the standard syntax <tt>$rates[1]</tt>.

<A NAME="expressions">
<h2>Expressions</h2>

As we saw in the previous paragraph, we can use a variable in instantiating
an object, by putting a <tt>$</TT> followed by the variable name in the object arguments.
The dollar sign is an evaluation operator, that applied to a name return the value
of the corresponding variable; the sequence <tt>$name</tt> is a very simple expression.

<P>
<I>j</I>Max actually support more complex expression; an object argument can be
defined as the result of an arbitrary complex expression; the expression syntax
is derived from the <i>C</i> programming language expressions, and include parentesys,
all the arithmetic, logic, bit-by-bit operators, the conditional operators, array access
and function calls, and the variable evalution operator <tt>$</tt>.

<P>
Also the object class can be defined by an expression. 
Functions calls are calls to a set of predefined functions; this release define a single
function, <tt>unique()</tt> that return a unique number each time is evaluated;
future releases will include a complete function library, and the possibility to define
functions thru a <i>C</i> API.

<P>
The arguments of an object must be <i><b>simple expressions</b></i>. 
A simple expression is either a variable access operation, an array access operation, 
or a expression between parentesys. 
In other words, an expression used as object argument should be enclosed in parenthesis.

<P>
In the following example patch, we define three variables to parametrize a 
table object size with respect to the sampling frequency; note that the variable 
<I>sr</I> will be a system defined variable in a real patch programming case.

<P>
<IMG SRC="../images/variable.gif" ALT="variables in patcher" BORDER=0>

<P>
Another way to define a variable in <I>j</I>Max is provided by the patcher
object.
A patcher object implicitly defines a variable <i>args</i> in it's context
containing the arguments of the patcher (including its name).

<P>
The arguments passed thru the <i>args</i> variable are positional parameters, 
i.e. they are assigned to positions in the <i>args</i> corresponding to 
their position in the patcher object. 
A patcher can also have named parameters, i.e. define new variables explicitly, 
adding at the end of the arguments a list of assignement in the form 
<tt>variable = value</tt>.

<A NAME="templates">
<h2>Templates</h2>

<P>
A template is the implementation of a new object in the <I>j</I>Max
language itself; a template <I>definition</I> is the content that will
be used to produce new objects; in <I>j</I>Max, any patcher can be used
as template definition, because, as we saw in the previous paragraph,
the language itself provide a generic mechanisms to pass arguments to
patchers, there is not need to make a distinction between a standard 
patcher file and a template definition file.

<P>
Since Templates use the same argument passing paradigm than all the
subpatchers, positional and named arguments can be used.

<P>
There are several way to define templates, depending on your configuration,
and on the project you are working on.
Please refer to the document section 
<A HREF="./projects.html">project environment settings</A> of this documentation 
for more powerfull project configuration.
Here we only describe the simplest way, usefull for small or personal developements.

The easiest way to define a template in <I>j</I>Max is the following:
define a directory to hold your templates, by using the templateDirectory command
in your .jmaxrc file, like this:

<UL>
  <DT><tt>templateDirectory /usr/joeMax/templates</tt>
</UL>

Any file <I>foo.jmax</I> saved to this directory will automatically define a
template called <I>foo</I>.
You can simply edit a patch and save it to this directory to define your 
first template.

<p>
This method has a problem (common to the ISPW Max environment): 
Since you are editing a template body, the variables (arguments or 
variables inherited from the outside scope) used by the template are 
not defined, so you can neither complete the editing, nor test the 
template body.

<p>
A better way is to create the template you want to define within the
context where you want to use it (or in a similar, ad hoc test
oriented context).  For example, in an empty patcher, create a
subpatcher object with some example arguments that you would give to
the template, create the template body, test it, and when it work
reasonably well, and save the subpatcher it to your template directory
using the menu item "Save To" in the patcher editor
Once saved, you can instantiate it as many time you want.

<p>
What we said about a new subpatcher apply as well to any template
instance; you can modify a template instance and save it as the new
definition for a template.
This is possible because the object text in the template instance 
is not changed, but stay exactly the same as in the template definition
(i.e. the definition of a template is one example instance).

<p>
Please note that saving a new template definition will automatically
redefine all the existing instances to conform to the new definition.

<P>
(Note: The template concept is very close to the abstractions of 
ISPW Max.
We use a different name to avoid confusion, since <I>j</I>Max is able
to load and use also the older ISPW Max abstractions.

<A NAME="lexical">
<h2>Lexical Conventions </h2>

<P>
Some simple lexical conventions are applied to whatever one types to 
a <i>j</i>Max object. On this level intergers, floats, symbols are 
recognized as follows:

<DL>
  <DT><b>integers</b>
    <DD>A string of an optional sign followed by decimal digits and 
      terminated by a terminating token is interpreted as an integer.<P>
  <DT><b>floats</b>
    <DD>A string of an optional sign followed by decimal digits, 
     followed by a decimal dot, followed by some more optional decimal 
     digits and terminated by a terminating token is intepreted as 
     a floating point number.<P>
  <DT><b>symbols</b>
    <DD>A string of characters included between double quotes is interpreted 
      as a symbol.
      A string of characters others than an int or a float terminated by a 
      terminating token is considered as a symbol; 
      a backslash followed by a terminating token is considered as a standard 
      character and do not terminate the symbol.<P>
</DL>

In addition to the blank charakter the following characters are acting as 
separators in any textual description of a <i>j</i>Max object:

<UL>
  <DT><tt><b>$ , ( ) [ ] { } : . ; '</b></tt>
</UL>

This makes for example that the text <tt><b>1,2</b></tt> actually represents 
three symbols "<b>1</b>", "<b>,</b>" and "<b>2</b>", while <tt><b>1+2</b></tt> 
represent a single symbol "<b>1+2</b>" 
(since the binary operators are not considered as separator tokens an expression 
with a binary operator like <tt><b>1 + 2</b></tt> must be written using blanks between 
the operands and the operator).

</DL>

<P>
(Note that the lexical conventions of <i>j</i>Max differ slightly from that 
ones of ISPW Max! Objects loaded from original ISPW patches are converted 
on the fly.)

<P>
</TABLE>
<HR NOSHADE SIZE=1>

</BODY>
</HTML>
