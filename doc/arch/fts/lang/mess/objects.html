<HTML>
<!--                                                                      -->
<!-- jMax                                                                 -->
<!--                                                                      -->
<!-- Copyright (C) 1999 by IRCAM                                          -->
<!-- All rights reserved.                                                 -->
<!--                                                                      -->
<!-- This program may be used and distributed under the terms of the      -->
<!-- accompanying LICENSE.                                                -->
<!--                                                                      -->
<!-- This program is distributed WITHOUT ANY WARRANTY. See the LICENSE    -->
<!-- for DISCLAIMER OF WARRANTY.                                          -->
<!--                                                                      -->
<HEAD>
<TITLE>The FTS Language Layer: Objects </TITLE>
</HEAD>

<BODY TEXT="#000000" BGCOLOR="#CCCCCC">

<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0>
<TR>
  <TD ALIGN=LEFT>
    <A HREF="http://www.ircam.fr/jmax/"><IMG SRC="../../../../../images/jmax_logo_tiny.gif" BORDER=0 ALT="jMax"></A>
  </TD>
  <TD ALIGN=RIGHT>
    <A HREF="http://www.ircam.fr/"><IMG SRC="../../../../../images/ircam_banner.gif" BORDER=0 ALT="IRCAM - Centre Georges Pompidou"></A>
  </TD>
</TR>
</TABLE>
<BR>
<UL TYPE=SQUARE>
  <LI><A HREF=../../../../index.html>Documentation</A>
  <UL TYPE=SQUARE>
    <LI><A HREF=../../../index.html><b>The <i>j</i>Max Architecture</b></a>
      <UL TYPE=SQUARE>
      <LI><A HREF=../../index.html><b>The FTS Computational Engine</b></a>
        <UL TYPE=SQUARE>
        <LI><A HREF=../index.html><b>The Language Layer</b></a>
	  <UL TYPE=SQUARE>
          <LI><A HREF=index.html><b>The Message System</b></a>
          </UL>
        </UL>
      </UL>
  </UL>
</UL>

<p>
<font size=+3 color=#FFFFFF><b>Objects</b></font>

<p>
<hr noshade size=1>

<UL TYPE=DOT>
  <LI><A HREF="#objects"> Objects </A>
  <LI><A HREF="#patchers"> Patchers</A>
  <LI><A HREF="#properties"> Properties</A>
  <LI><A HREF="#errors"> Error Objects </A>
  <LI><A HREF="#files"> Related Files </A>
</UL>

<p>
<hr noshade size=1>

<TABLE WIDTH=100% BORDER=0 CELLSPACING=1 CELLPADDING=20 BGCOLOR=#FFFFFF>
<TR><TD>
  
<A NAME="Objects"> 
<H2> Objects </H2> 
<p>
From the patch programmer point of view, an object is the elementary
unit he use to build up a MAX program; they are the equivalent to
basic language statement and definitions in a standard programming
language.
<p>
In order to execute this program, <i>j</i>Max, as its predecessors,
use an object oriented interpreter; each statement/definition is
represented with an C object implemented using what we call the FTS
message system, that have features that resemble from some point of
view some of the characteristic of some object oriented languages
(in the old time when you called a generic function by sending
a message to an object).
<p>
"Max" messages are mapped to messages in messages to these objects,
and executed by executing these objects methods.
<p>
This cover primitive <i>j</i>Max objects like "int" or "float"; but currently
the <i>j</i>Max language is a lot richer, including the definition of new objects
in terms of the language itself (template and old abstractions), variables
and expressions and so on.
<p>
So when a user type an object description in an object box, the result
is not always the creation of a single object, but actually can include
much more work, like loading files, redefining other objects and so on;
so there are two meaning in the system for <i>creating an object</i>,
one is to process a language level object description and do all the needed
work to add this statement to the program (implemented by the C function
<code>fts_eval_object_description</code>, and actually instantiating an instance of a
class of the FTS message system (implemented by the C function 
<code> fts_object_new</code>); these two functions are documented
below.
<p>
Changing and deleting an object require also that all effects tied to
variables are propagated in the right ways, so also these functionalities
need to be explained.
<p>
One non-user visible mechanism that <i>j</i>Max define is the <i>object doctor</i>,
essentially a macro processor for object description where macros are defined
as C functions, and can do invisible or visible transformation on objects; quite
usefull, for example, to keep compatibility between different version of objects
by automatically translating the old object syntax in the new syntax.
<p>

<H4> Creating an FTS message system instance</H4> 
<p>
It is done by the <code>fts_object_new</code> function.
<p>
The object creation is pretty straighforward; including a call to the
class discrimination mechanism to find the right class, allocating and
initializing the system part of the object, adding it to the container
patcher, and calling the object initialization (the init method).
<p>
Things worth to note:
<p>
<ul>
<li> In <i>j</i>Max, objects know in which patcher they are; they can
refer to the context of the patcher for various purposes, notably
variable handling.
<li> Patcher are not handled as standard objects, and always assigned to the
same class; see the patcher chapter for details.
<li> The init message is alway sent with all the checks active; see the
message chapter for details on optional run time checks.
<li> While the object include in its state its description (i.e. the
text given by the user parsed as a list of atoms) this function do not
initialize it; the description is seen has an high level functionalities,
and is handled in the language level object creation.
</ul>

<H4> Creating a <i>j</i>Max object</H4> 

The language work is done in the <code>fts_eval_object_description</code> function;
given a description, a number of things in the right order need to be
done.

<ol>
<li> Variable preparation <br>
If the object description define a variable ("foo : const 10")
syntax, the variable need to be defined, in order to inform the
variable propagation algorithm that we are adding a new variable in
the local context; this action can have quite a number of side
effects; note that the variable is defined before the object is
created, so we don't have a value for the variable; the variable will
be set later; this mechanism is needed to prevent loops in variable
value propagation; see the chapter on variables for details.<p>
<li> Doctor<br>
We check now if there is a object doctor (a C coded macro) registered
on the class name of this object; we do it here to give the macro a chance
to change the object before the expression evaluation; but, since also
the class name can be the result of an expression evaluation, we will need
to retry this after the expression evaluation.
See the paragraph on object doctors for details on what a doctor can actually
do and how.<p>
<li> Expression evaluation <br>
Taken away the variable definition (if any) the rest of the
description is evaluated by the expression evaluation; every
expression is subtituted by its value; in the process, the expression
evaluator produce a list of the variable used in this evaluation, and
a list of name/value pairs corresponding to the assignement syntax at
the end of the description (corresponding to named variables for
templates and patchers); see the expression chapter for details
on expression evaluation.<p>
<li> Doctor (II)<br>
We re-check for doctors after the expression evaluation,
for the reasons explained above.<p>
<li> Explicit templates<br>
We check if the class name correspond to an explicitly declared
template, i.e. currently declared with the tcl macro <code>template</code>.
Doing this before trying a standard FTS class allow an explictly declared 
template to overwrite a C written class, for example a library class.<p>
<li> Explicit Abstractions<br>
If we hav'nt created the object yet, we check if the class name correspond to an explicitly declared
abstraction, i.e. currently declared with the tcl macro
<code>abstraction</code>.  Doing this before trying a standard FTS
class allow an explictly declared template to overwrite a C written
class, for example a library class.  
<i>abstractions</i> are the Max 0.26 and FTS 1.5 abstraction
mechanism; <i>j</i>Max can read old abstractions, but cannot save new
ones.<p>
<li> Standard FTS objects<br>
If we have not created the object yet, the <code>fts_object_new</code> function is called, to build
a standard FTS object if the right class exists; see above.<p>
<li> Template on a declared template Path<br>
If we have not created the object yet, we check if a template with the correct
name exists in one of the template path declared (currently template path
are declared with the <code>templateDirectory</code> tcl command).
Note that template on a template path do not overwrite standard FTS class;
the reason is a matter of loading perfomance: if a template on a template path
would overwrite an FTS class, we had to look for the template file before
looking for the FST class for <strong>all</strong> the objects instantiations,
with a fenomenal degradation in loading performance (a file system call
for every template path for every object loaded).<p>
<li> Abstractions on a declared abstraction Path<br>
If we have not created the object yet, we check if a abstraction with the correct
name exists in one of the abstraction path declared (currently abstraction path
are declared with the <code>abstractionDirectory</code> tcl command).
As for templates, an abstraction on an abstraction path do not overwrite standard FTS class.
<p>
<li> Error object <br>
If we have not created the object yet, create a fake error object; an error object
is a special object that work as a place holder for all the connections, and have a special
error properties for user interface purposes; see the Error object chapter for details.<p>
<li> Check the variable value<br>
In case the description define a variable, check if the object can actually
define a variable, i.e. do export a <code>state</code> property; if it cannot,
substitute the object with an error object. <p>
<li> Set the object description <br>
If the previous object creation process have not set the object description,
assign it; for example, a doctor can have translated on the fly an object to another
one, producing also the new description, so in this case we should not set the 
original one.<p>
<li> Register itself as user of the used variables<br>
Register the created object as user of the variable used in the expression evaluation;
this links will allow the object to be redefined if some of these variables change values.
<p>
<li> Handle the assignements<br>
Get the expression assignements and assign them to internal variables
in case of patchers or templates, or to object properties in case of
standard objects.
<p>
<li> Restore of the variable value<br>
Now that the object exists, the state property value can be assigned
to the defined variable (if any); this action will have as effect the redefinition
of all the objects depending on this variable.
<p>
</ol>

Of course, the code have also to deal with a number of error
checks in between all this phases.

<H4> Deleting an Object </H4> 
<p>
Deleting an object (function <code>fts_object_delete</code> is a multiple 
phases operation; first, we <code>reset</code> the object (function
<code>fts_object_reset</code>), i.e. we take it away from the variable
propagation network; if this object define a variable, it is
undefined, and all the objects depending on it are recomputed; and the
object is removed from the user list of the variables referred during
its instantiation.
<d>
Second, the <code>delete</code> message is sent to the object, so that
the object can free its resources. <br> Third the object is removed
from the list having property changes (function
<code>fts_object_reset_changed</code>); to keep this list consistent
(otherwise, deleting an object having a pending update would cause a
crash).  <br> 
Finally the object is freed (function <code>fts_object_free</code>)
all its connections are deleted, system structures are updated
(patcher object, id table and so on), its private data structure are
freed.  Deleting an object can optionally be done without destroying
the client counterpart, if any; this feature is important when
redefining/recomputing an object, because we want to leave the object
identity intact on the client side.
<p>
<H4> Redefining an Object </H4> 
<p>
In the message system, we talk about two slightly different concepts,
recomputing an object, and redefining an object.
<p>
To recompute (function <code>fts_object_recompute</code>) an object
means to redefine it with the same description, taking care of
communicating the modification to the client, because the recomputing
is always a server initiative, tied to variable propagation;
recomputing is used when a variable the object depend on change value;
its implementation release the object edited data (value of the <code>data</code>
property), i.e. close any editor opened on the object "content", redefine
the object using the object description as new definition, and finally
upload the <i>kernel</i> properties to the client if needed.
<p>
To redefine an object (function <code>fts_object_redefine</code>)
means to substitute it with a new one, with potentially a different
description in the patcher, without telling the other objects or the
client; connections are moved to the new one and id are kept.
<p>
Redefining patchers is done with a different strategy, to avoid loosing
their content; see below for details.
<p>
The object redifinition algorithm is the following:
<ol>
<li> If the new object description define the same variable as the old
one the variable is suspended: essentially this means that while the
variable name does still exists in its scope, any access to its value is 
illegal; suspending a variable is an essential concept in the variable 
propagation mechanism, see the relative chapter.
<p>
<li> If the new object keep the same id, update the object  table
to reflect the new binding of the id.
<p>
<li> As during an object delete, remove the old object from the
variable propagation structure.
<p>
<li> Prepare for data trasfer if needed, send the delete message otherwise.
<p>
<li> Build the new object, using the standard <code>fts_eval_object_description</code> function.
<p>
<li> Fix the internal structures of the loading vm: if we are loading
a <i>j</i>Max file, the vm may refer the object being redefined (in
the object table); the references are transparently converted to the
new object.
<p>
<li> If the new object one is an error object, set its number of inlets and outlets
to be equal to the ones of the old object.
<p>
<li> Copy standard properties (like x and y position) from the old object to the new one.
<p>
<li> Offer the two objects a chance to exchange  data by means of a <code>redefining</code>
message, only if the old object defined a method for the <code>release</code> message.
<p>
<li> Move all the  connections from the old object to the new one, keeping their client
identity if any.
<p>
<li> Complete the deleting of the old object, by calling <code>fts_object_free</code>.
<p>
</ol>

<P>
<H4> Doctors</H4> 
<p>
An object doctor is a macro expansor for object definition, written as a C function;
a specific object doctor is bound to a class name, and invoked during the object creation
process.
<p>
We way identify three kinds of doctors:
<dl>
<dt> Invisible doctors. <br>
<dd> An invisible
doctor produce a macro expansion that is not visible to the user (and
so not persistent); the expanded object keeps the same description as
the original; an object doctor of this kind usually produce the
expanded object description starting from the original description,
create the new object by calling <code>fts_eval_object_description</code> and then
remove the object description of the created object using the
<code>fts_object_reset_description</code>; this will cause the object
creation function to install the original description on the object;
the <code>argument</code> is actually implemented as an object doctor
producing a <code>const</code> object.<p>
<dt> Visible doctor.
<dd> A visible doctor produce a user visible and
persistent transformation of an object; this trasformation is usefull
in case like automatically updating a patch to a different syntax, in
case of object changes.  An example of use if for example the
automatic translation of an old version of the comment object to the
current version.<p>
<dd>
<dt> Special purpose 
<dd>
A doctor have a lot of freedom in trapping the object creation mechanism;
freedom that can be quite usefull, and of course dangerous, in some special
situation; for example, an object doctor can instantiate an object calling
directly <code>fts_make_objecy</code>, to avoid recursive calls to himself
and expression evaluation; this technique is used to transform old instances
of exp to the new syntax, prevening any interaction with the new expression
mechanism.<p>
</dl>
<b>Note</b>: <i>there is a conceptual bug that should be fixed in the
way doctors work: as said above, a doctor can be called before or
after the evaluation of the expressions defining the object; but, the
doctor function have no way to know if the expressions has been
evalutated or not, so it is not clear if the
<code>fts_eval_object_description</code> function or the
<code>fts_object_new</code> should be called; calling the first can
produce inespected results when the result of the previous evaluation
is still an expression; calling the second can fail because the
expressions have not been evaluated; the doctor mechanism should be
refined to give more information to the doctor function </i>.
<P>

<A NAME="patchers"> 
<H2> Patchers </H2> 
<p>
Patchers are very special objects in FTS; their main characteristic is
that they can dynamically change of class (not metaclass), so they can
change dynamically their number of inlets and outlets; in general a
patcher cannot be redefined by reinstantiation, in order to avoid
loosing their content; also, patchers represent <i>contexts</i> in
different case, like update handling and variable resolution; all this
require a dedicated support right in the kernel of the message system.
<p>
<H4>Patchers Inlet and Outlets</H4>
<p>
Main role of a patcher is to present a group object as a single entity
in the parent patcher; in order to allow to communicate with its content,
the patcher have inlets and outlets, that are mapped to inlet and outlet
objects inside the patcher.
<p>
This mapping is handled by the patcher itself; the inlet/outlet object
are not a lot more than placeholders for connections, rerouting,
together with the patcher object itself, messages from or to the
outside of the patcher.
<p>
A patcher is always instantiated without inlets and outlets; then,
adding inlets and outlets objects will automatically change its number
of inlet and outlet; a new inlet/outlet object can be instantiated
with a given position, or can automatically require the next available
position; changing the number of inlets or outlets dynamically require 
from one side finding out the new class instance, on the other side change
the object system structures to reflect the new number of inlets/outlets;
this work is done in functions 
<code>fts_patcher_redefine_number_of_inlets</code> and 
<code>fts_patcher_redefine_number_of_outlets</code>.
<p>
When edited, inlet and outlet objects are not redefined; they are just repositioned,
and the patcher updated.
<p>
Inlet and outlet objects require special handling for loading a .pat file;
they are loaded <i>inactive</i>, in the sense they are stored in the
patcher but the patcher is not redefined, and only when the whole
patcher has been read, the inlets and outlets are analized and sorted
starting from their <code>x</code> position and really positioned in the
patcher.
<p>
<H4>Patcher Variables</H4>
<p>
As objects, patchers can now define a variable; the variable is bound
to the patcher itself, i.e. to a variable scope; this is made to allow
composed name and inter-scope access for variables; <i>note that the
variable value propagation engine do not yet support this feature</i>.
<p>
Also, in order to parametrize the patcher content, a patcher can define
a number of internal variables; the array variable args, that include
a number of positional arguments, and a number of keyword argument.
The variable are defined and handled with techniques similar to those
of objects.
<p>

<H4>Patcher Redefinitions</H4>
<p> 
Patchers have a special redefine strategy: since we don't want its content
to be lost; also, note that changing the description of a patcher
do not change its number of inlets/outlets, that is instead changed by adding
inlets/outlet objects inside the patcher; the patcher redefinition algorithm (function 
<code>fts_patcher_redefine</code>) is the following:

<ol>
<li> Set the patcher description to the new decription.
<li> Handle variable definition: if the patcher defined a variable before
the redefinition, and do not define the same variable now, undefine the old variable;
otherwise suspend it; define the new one if any.
<li>Suspend the old argument variables.
<li>Eval the patcher arguments expression.
<li> Restore the argument variables, either positional or keyword, using
the result of the expression evaluation.
<li>Register the patcher as user of the variables accessed during
the expression evaluation.
<li> Undefine all the variable that are still suspended, i.e. old key and
positional arguments that have not been redefined.
<li> Restore the variable the patcher define, if any.
<li>Inform the UI of the changes.
</ol>

<p>
<H4>Patchers and templates, abstractions, error objects</H4>
<p>
Given their ability to change number of inlets, patchers are used to
implement abstractions, templates and error objects; this means that
all they integrate the house keeping code for template instances, for
example.
<p>
Actually, a template or an abstraction consists precisely of a
patcher; the argument passing mechanism of templates is actually the
same mechanism that allow a patcher to define internal variables; the
template specific code regard only the mapping of names to files, the
loading of those files and the automatic reinstantiation of templates
during editing; see the relative chapter for details.
<p>
Error objects need to emulate input/output behaviour of other objects;
this is why they are actually implemented with patchers; a internal
flag prevent some of the operation to be done on a patcher that is actually
an error object.
<p>
<H4>Content Editing </H4>
<p>
In order to export the patcher content to a client editor, 
patchers define a data property, that is a <code>patcherdata</code> 
used to export the content of a patcher to the application layer; actually,
a patcher editor is an editor of patcherdata; this features can be blocked
with a special property, to make the patcher not editable.
<H4>Other features</H4>
<p>
Patchers directly support a number of extra features:
<ul>
<li>Load bangs: the load init message is automatically propagated to its content;
the mechanism guarantee that the inner patchers are initialized before the standard
objects.
<li>Support for find: look for atoms occurencies in a patcher content,
and recursively in all its subpatchers.
<li>Support for find error: look for error objects in its content and
recusively in all its subpatchers.
<li>Deleting an patcher: patchers can recursively delete their content.
<li>Update control: a patcher keep track of open editors, and this is used to enable/disable
updates from its content.
<li>Support for blips, i.e. context dependent messages usually shown in 
the first ancersto open patcher status line.
</ul>

<A NAME="properties"> 
<H2> Properties </H2> 
<p>
Object properties are a system, and not a language, feature;  essentially consists
of associating to each object a dynamic associative list mapping a symbol to a single
atom value, so that each part
of the system can use properties as <i>block-notes</i> during computation
about objects; they are currently used to implement all the language features
different from the object description; for example, position and color (since we
have a visual language, these are language and not ui feature).
<p>
Properties, together with object description, are the basic FTS mechanism
for persistency: only escription and properties of an object are saved to 
a file; properties are also used to represent those dynamical characteristic
of an user interface object that are affect the interface at run time;
see the update mechanism description.
<p>
Properties are stored/retrieved at three level: explicitly at the object level,
explicitly at the class level, and implicitly thru class daemons; a daemon
is a function that can override the standard system behaviour for setting/getting
a property.
When getting the property from an object, the system first check if the property
has been  explictly set on the object, then check the class property as a default
value, and if not yet found, check if there is daemon available to compute this
property on the fly; also when setting an object property the system check if 
there is a daemon for setting the property; daemons can be also define for
the remove property operation.
<p>
The property implementation is straightforward: they are stored in an associative 
list for each object, or in the class, and the class have a unique daemon list with tags 
for the action type.
<p>
<i>Currently there is no way to define global daemons, i.e. deamons that are applied for 
all the objects for a given property; this can come handy for example for some system wide
or UI relative property (like for example a property like <code>is_dsp</code>)</i>
<p>
<i>Currently, the set of properties of an object save to a patcher file is hardwired; 
the set of properties uploaded to the client for editing is fixed, but each object can
define some more with a special method. This is not very correct; each object should
define its own persistent and uploaded properties; in this way the kernel handle
a group of properties that are actually dependent on the objects.</i>
<p>
The FTS kernel define a number of properties; the following table include
all the properties the kernel use; some of the properties are applicable to 
all objects, or may just to one or two.
<p>

<TABLE BORDER>
<CAPTION> Kernel Defined Properties </CAPTION>
<TR><TH> Property Name</TH> <TH>Meaning</TH> <TH>Automatically<br>Uploaded</TH> <TH>Saved</TH><TR>

<TR><TD>name</TD> <TD>Name of the object.<br> Used to in converting .pat explode</TD> <TD>N</TD> <TD>N</TD><TR>
<TR><TD>ninlets</TD> <TD>Number of object inlets</TD> <TD>Y</TD> <TD>Y</TD><TR>
<TR><TD>noutlets</TD> <TD>Number of object outlets</TD> <TD>Y</TD> <TD>Y</TD><TR>

<TR><TD>x</TD> <TD>object x position</TD> <TD>Y</TD> <TD>Y</TD><TR>
<TR><TD>y</TD> <TD>object y position</TD> <TD>Y</TD> <TD>Y</TD><TR>
<TR><TD>width</TD> <TD>object width</TD> <TD>Y</TD> <TD>Y</TD><TR>
<TR><TD>height</TD> <TD>object height</TD> <TD>Y</TD> <TD>Y</TD><TR>

<TR><TD>wx</TD> <TD>object window x position</TD> <TD>Y</TD> <TD>Y</TD><TR>
<TR><TD>wy</TD> <TD>object window y position</TD> <TD>Y</TD> <TD>Y</TD><TR>
<TR><TD>wh</TD> <TD>object window height</TD> <TD>Y</TD> <TD>Y</TD><TR>
<TR><TD>ww</TD> <TD>object window width</TD> <TD>Y</TD> <TD>Y</TD><TR>

<TR><TD>font</TD> <TD>Object font</TD> <TD>Y</TD> <TD>Y</TD><TR>
<TR><TD>fontSize</TD> <TD>Object font size</TD> <TD>Y</TD> <TD>Y</TD><TR>

<TR><TD>color</TD> <TD>Object Color (for buttons)</TD> <TD>Y</TD> <TD>Y</TD><TR>
<TR><TD>comment</TD> <TD>Comment Text (comment objects)</TD> <TD>Y</TD> <TD>Y</TD><TR>

<TR><TD>layer</TD> <TD>z position of an object</TD> <TD>Y</TD> <TD>Y</TD><TR>

<TR><TD>max_value</TD> <TD>Max value (for sliders)</TD> <TD>Y</TD> <TD>Y</TD><TR>
<TR><TD>min_value</TD> <TD>Min value (for sliders)</TD> <TD>Y</TD> <TD>Y</TD><TR>

<TR><TD>error</TD> <TD>If not zero, this is object have an error</TD> <TD>Y</TD> <TD>N</TD><TR>
<TR><TD>error_description</TD> <TD>textual description of an error</TD> <TD>Y</TD> <TD>N</TD><TR>

<TR><TD>no_upload</TD> <TD>if set, the object cannot be uploaded</TD> <TD>N</TD> <TD>N</TD><TR>
<TR><TD>state</TD> <TD>If set, its value can be assigned<br>
to the variable defined by this object</TD> <TD>N</TD> <TD>N</TD><TR>
<TR><TD>patcher_type</TD> <TD>the type of a patcher <br> 
(template/abstraction/standard patcher)</TD> <TD>Y</TD> <TD>N</TD><TR>
<TR><TD>data</TD> <TD>if set, its value will be edited <br>
when the object is double clicked<br>
its value must be an <code>fts_data_t</code></TD> <TD>N</TD> <TD>N</TD><TR>
<TR><TD>filename</TD> <TD>The file a patcher has been loaded from<br>
currently used for autosave</TD> <TD>N</TD> <TD>N</TD><TR>
</TABLE>
<P>

<A NAME="errors"> 
<H2> Error Objects</H2> 

With the term <i>error objects</i> we actually identify two different things:
a normal object that is, in its own code, signalling an initialization error to the user by becoming
red, and a real error object, i.e. a place holder for an object that the message system
could not instantiate at all for some reason.<p>
In the first case, we just have an object that set the <code>error</code>
and <code>error_description</code> properties properly, possibly using the
<code>fts_object_set_error</code> function.<p
In the second case we have an instance of a patcher, marked as an error,
that is able to adapt to add inlets and outlets when new connections are done;
during the loading of a patch, this allow to instantiate the connections stored
to a file also if they start or arrive to an object that cannot be instantiate
in the loading context; in this way the patcher can be seen without loosing
information, and a fix is possible.<p>
The error object system define also a call (<code>fts_recompute_errors</code>
and <code>fts_do_recompute_errors</code>) to try to recompute all the objects
with errors; this is done when some big environmental changes happen (for
example, a new template directory  is added), to give a chance to fix
configuration errors without reloading the edited patches.
<p>

<p>
<A NAME="files"> 
<H2> Related Files</H2> 
<P>

<ul> 
<li> <code>objects.c</code>
<li> <code>objects.h</code>
<li> <code>doctor.c</code>
<li> <code>doctor.h</code>
<li> <code>patcher.c</code>
<li> <code>patcher.h</code>
<li> <code>properties.c</code>
<li> <code>properties.h</code>
<li> <code>errobj.c</code>
<li> <code>errobj.h</code>
</ul>

</TABLE>

<HR NOSHADE SIZE=1>

</BODY>
</HTML>


