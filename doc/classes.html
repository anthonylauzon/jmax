<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html><head>  <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">  <title>jMax Documentation</title></head><body><h1>FTS classes</h1>FTS, the server engine of jMax, has a small C written object systemincluding a simple garbage collector (by reference count). Basicallyany typed values apart from integers, floats and symbols are objects.The most known examples of FTS classes might still be those of theobjects inside a patcher such as sliders, buttons or oscillators. Butas well vectors or MIDI events, rather sent between the objects in apatcher than themselves instantiated in a patcher window, are typicalexamples of FTS classes.<br><br>Classes can implement methods for messages and inlets of an object anddeclare outlets. Methods of an object can be called by:<br><ul>  <li>receiving a message directly sent to the object</li>  <li>receiving a message sent to the first inlet of the object fromthe outlet of another object</li>  <li>receiving values sent to an inlet of the object from the outletof another object</li></ul>Methods can output values from an outlet of the object or return valuesto the FTS object system.<br><br><hr style="width: 100%; height: 2px;"><ul>  <li><a href="#Packages">Packages</a><br>  </li>  <li><a href="#Class_structure">Class structure</a></li>  <li><a href="#Constructor_and_deconstructor">Constructor anddeconstructor</a><br>  </li>  <li><a href="#Method_declaration">Method declaration</a></li>  <li><a href="#Inlets_and_outlets">Inlets and outlets</a><br>  </li>  <li><a href="#Method_implementation">Method implementation</a></li>  <li><a href="#Method_invocation_">Method invocation</a></li>  <li><a href="#Error_handling">Error handling</a><br>  </li></ul><hr style="width: 100%; height: 2px;"><h3><a name="Packages"></a>Packages<br></h3>An FTS class always lives in package. Packages bundle componentsdedicated to the use with FTS to be distributed and dynamically linkedto the running system when required. A package named <span style="font-style: italic;">papou</span> basically consists of thefollowing:<br><ul>  <li>a directory <span style="font-style: italic;">papou</span> withan&nbsp;optional package description file <span style="font-style: italic;">papou.jpkg</span></li>  <li>a shared library named after a platform dependent convention(such as <span style="font-style: italic;">libpapou.so</span> for UNIXplatforms) containing the class definitions and whatsoever other modulesyou want to bind to the system</li>  <li>an initialization function named <span style="font-style: italic;">papou_config</span> implemented by thelibrary and called when it is linked</li>  <li>a directory <span style="font-style: italic;">help</span>containing a help summary patch and help patches for the classesimplemented<br>  </li></ul><hr style="width: 100%; height: 2px;"><h3><a name="Class_structure"></a>Class structure<br></h3>Since we are in C your FTS class will be represented by a C structure.In order to be an FTS class this structure must have the structure <span style="font-style: italic;">fts_object_t</span> as first field and istypically defined as a type named after the class:<br><pre>  typedef struct<br>  {<br>&nbsp;   <span style="font-weight: bold;">fts_object_t</span> o;<br><br>  &nbsp; /* here follows the fields of your class */<br><br>  } coucou_t;<br></pre>In order make your class useable you must declare it to FTS by a calllike this:<br><pre>  fts_class_install(fts_new_symbol("<span style="font-weight: bold;">coucou</span>"), <span style="font-weight: bold;">coucou_instantiate</span>);<br><br></pre>Make sure that this call is executed by the initialization function ofthe package it belongs to.<br><br>The class instantiation function (here<span style="font-style: italic;"> </span><span style="font-style: italic;">coucou_instantiate</span>) contains theinitialization and definition of the class. The most essential call ofthis function is <span style="font-style: italic;">fts_class_init</span>,which is usually followed by message, inlet and outlet declarations forthe class:<br><pre>  static void<br>  coucou_instantiate(fts_class_t *cl)<br>  {<br>    <span style="font-weight: bold;">fts_class_init</span>(cl, sizeof(coucou_t), coucou_init, coucou_delete);<br><br>    /* ... message, inlet and outlet declarations */<br>  }<br><br></pre>The <span style="font-style: italic;">fts_class_init</span> declaresthe size of an object of the given class (is the size of the C structurefrom above) as well as an optional constructor and de-constructormethod (both can be set to <span style="font-style: italic;">NULL</span>).<br><br><hr style="width: 100%; height: 2px;"><h3><a name="Constructor_and_deconstructor"></a>Constructor anddeconstructor</h3>A class of objects which have to be initialized or allocate additionalmemory at creation (and deallocate when deleted) has to implement aconstructor and deconstructor. Both are implemented in the same way asmethods (see down). The constructor is called with the instantiationarguments of the object.<br><br><hr style="width: 100%; height: 2px;"><h3><a name="Method_declaration"></a>Method declaration</h3>Methods in FTS can be invoked by messages or via inlets. Even ifmessages can be send to the first inlet of an object they are handled asif they were directly sent to the object. The declaration(and&nbsp;dispatch) of a method invoked by a message with argumentvalues is almost identical to that of a method invoked by values sent toan inlet. The former is declared for a given message symbol andargument type, the latter for an inlet and value type. The followingfunctions are used in the body of the class instantiation function:<br><pre>  fts_class_message(cl, fts_new_symbol("set"), NULL, coucou_set)<br><br> &nbsp;fts_class_inlet(cl, 0, NULL, coucou_set)<br></pre>Regarding these two example declarations a message <span style="font-style: italic;">set</span> to an object of the given class <span style="font-style: italic;">cl</span> here is equivalent to sendingonly its argument value into the first inlet (index 0). Both invoke themethod <span style="font-style: italic;">coucou_set</span>.<br><br>If <span style="font-style: italic;">NULL</span> is given as argumenttype, as in the example, the method will be invoked for a singleargument of any type.<br><br>A method with multiple argument values can be declared in two ways:either as method for a single value of the type <span style="font-style: italic;">fts_tuple_class</span> receiving the valuesas a single tuple atom or as a <span style="font-style: italic;">varargs</span>method receiving the values in an array (<span style="font-style: italic;">ac, at</span>). If necessary the creationof a tuple object or the unpacking of a tuple object to an array ofarguments is implicitly handled by the FTS method dispatcher. <br><br>For the declaration of varargs methods the following function callswithout argument type are used:<br><pre>  fts_class_message_varargs(cl, fts_new_symbol("set"), coucou_set_varargs)<br><br> &nbsp;fts_class_inlet_varargs(cl, 0, coucou_set_varargs)<br></pre>A set of macros is provided for the declaration of methods for the mostoften used data types:<br><pre>  fts_class_message_int(cl, fts_new_symbol("set"), coucou_set_number)<br>  fts_class_message_float(cl, fts_new_symbol("set"), coucou_set_number)<br>  fts_class_message_number(cl, fts_new_symbol("set"), coucou_set_number)<br>  fts_class_message_symbol(cl, fts_new_symbol("set"), coucou_set_symbol)<br>  fts_class_message_tuple(cl, fts_new_symbol("set"), coucou_set_tuple)<br>  fts_class_message_atom(cl, fts_new_symbol("set"), coucou_set_any_atom)<br><br> &nbsp;fts_class_inlet_int(cl, 0, coucou_set_number)<br>  fts_class_inlet_float(cl, 0, coucou_set_number)<br>  fts_class_inlet_number(cl, 0, coucou_set_number)<br>  fts_class_inlet_symbol(cl, 0, coucou_set_symbol)<br>  fts_class_inlet_tuple(cl, 0, coucou_set_tuple)<br>  fts_class_inlet_atom(cl, 0, coucou_set)<br></pre>The ...<span style="font-style: italic;">_atom</span> functions areequivalent to the calls with <span style="font-style: italic;">NULL</span>as argument type. The functions ...<span style="font-style: italic;">_number</span>are strictly equivalent with an <span style="font-style: italic;">int</span>declaration followed by a <span style="font-style: italic;">float</span>declaration.<br><br>For methods called without argument values the following decalarationsare used:<br><pre>  fts_class_message_void(cl, fts_new_symbol("doit"), coucou_doit)<br><br> &nbsp;fts_class_inlet_void(cl, 0, coucou_doit) /* same as fts_class_inlet_bang */<br><br></pre>Note that the former MAX <span style="font-style: italic;">bang</span>message is strictly equivalent to sending a single void value or <span style="font-style: italic;">no values</span><span style="font-style: italic;"> at all</span> (but do sending anyway)<span style="font-style: italic;"></span> to an inlet.<br><br>A method declared for a varargs is called for any number and type ofarguments as well as without arguments (or <span style="font-style: italic;">bang</span>) if no other method isdeclared for the same message or inlet.<br><br>One can not declare for the same message or inlet a varargs method <span style="text-decoration: underline;">and</span> a method for an atom ofan arbitrary type (giving <span style="font-style: italic;">NULL</span>as argument type or using the ...<span style="font-style: italic;">_</span><span style="font-style: italic;">atom</span> call for the declaration). Inthe same way the declaration of a varargs mathod is mutual exclusivewith the declaration of a tuple method for the same message or inlet.<br><br><hr style="width: 100%; height: 2px;"><h3><a name="Inlets_and_outlets"></a>Inlets and outlets</h3>The declaration of a method for an inlet automatically adds an inlet tothe class if necassary. The function <span style="font-style: italic;">fts_class_inlet_thru</span>adds a passive inlet to the class, which doesn't correspond to a methodcall:<br><pre>  fts_class_inlet_thru(cl, 0)</pre>Outlets have to be declared using the function <span style="font-style: italic;">fts_class_outlet</span> with the class, theindex of the outlet and a type<span style="font-style: italic;"></span>class:<br><pre>  fts_class_outlet(cl, 0, fts_void_class<span style="font-style: italic;"></span>)<br>  fts_class_outlet_varargs(cl, 0)<br>  fts_class_outlet_message(cl, 0<span style="font-style: italic;"></span>)<br>  fts_class_outlet_thru(cl, 0)<br></pre>Here the <span style="font-style: italic;">NULL</span> value indicatesan untyped outlet. The function <span style="font-style: italic;">fts_class_outlet_thru</span>adds an untyped outlet to the class.<br><br>For the most used outlet types the following short cuts are provided:<br><pre>  fts_class_outlet_void(cl, 0) /* same as fts_class_outlet_bang */<br>  fts_class_outlet_int(cl, 0)<br>  fts_class_outlet_float(cl, 0<span style="font-style: italic;"></span>)<br>  fts_class_outlet_number(cl, 0)<br>  fts_class_outlet_symbol(cl, 0)<br>  fts_class_outlet_atom(cl, 0)<br></pre>Even if the number of inlets and outlets of a class is determined bythe declarations from above, an object of a given class can have anynumber of inlets and outlets. By default an object has the number ofinlets and outlets given in the definition of the class. Two functionsare provided in order to change the number of inlets and outlet of anobject, which are called with the object and the number of inlets oroutlets desired:<br><pre>  fts_object_set_inlets_number(o, n)<br>  fts_object_set_outlets_number(o, n)<br></pre>Two corresponding functions return the current number of in lets oroutlets as an integer:<br><pre>  fts_object_get_inlets_number(o)<br>  fts_object_get_outlets_number(o)<br></pre><br><hr style="width: 100%; height: 2px;"><h3><a name="Method_implementation"></a>Method implementation<br></h3><h3> </h3>In general methods are statically declared functions of the followingshape:<br><pre>  static void<br>  coucou_set_number(fts_object_t *<span style="font-weight: bold;">o</span>, int <span style="font-weight: bold;">winlet</span>, fts_symbol_t <span style="font-weight: bold;">s</span>, int <span style="font-weight: bold;">ac</span>, const fts_atom_t *<span style="font-weight: bold;">at</span>)<br>  {<br>    coucou_t *self = (coucou_t *)o;<br>    int n = fts_get_number_int(at);<br><br>    if(n &gt; 0)<br>      self-&gt;count = n;<br>    else<br>      self-&gt;count = 0;<br>  }<br></pre>The first argument (<span style="font-style: italic;">o</span>) of amethod is the object itself, which is typically casted in the first lineof the function to the class' data type in order to access the fieldsof the C structure. The second argument (<span style="font-style: italic;">winlet</span>) is the index of the inletif the method was invoked via an inlet or the negative value <span style="font-style: italic;">fts_message_inlet</span> if the method isinvoked via an inlet. The third argument (<span style="font-style: italic;">s</span>) is the message symbol for amethod invoked by a message or <span style="font-style: italic;">NULL</span>otherwise. The fourth and fifth arguments (<span style="font-style: italic;">ac</span> and <span style="font-style: italic;">at</span>) are size and values of thearray of arguments passed to the method as atoms.<br><br>Note that the arguments are passed by the message system as an array ofconstant atoms. This means that a method cannot modify its arguments.Modifying the arguments of a method in the body of the method can leadto unpredictable side effects. If this is needed for convenience, thearguments must first be copied. <br><br>Atoms are generic FTS values which can have any of the data types: <span style="font-style: italic;">int</span>, <span style="font-style: italic;">float</span> (in C 64-bit <span style="font-style: italic;">double</span> format), <span style="font-style: italic;">symbol</span>, <span style="font-style: italic;">object</span> (pointer to <span style="font-style: italic;">fts_object_t</span>).&nbsp;The followingfunctions are provided to access the atom values:<br><pre>  fts_get_int(at) /* get int value from int atom */<br>  fts_get_float(at) /* get double value from float atom */<br>  fts_get_number_int(at) /* get int value from int or float atom */<br>  fts_get_number_float(at) /* get double value from int or float atom */<br>  fts_get_symbol(at) /* get symbol from symbol atom */<br>  fts_get_object(at) /* get object from object atom */</pre>For testing the type of an arbitrary atom the following booleanfunctions are provided:<br><pre>  fts_is_int(at)<br>  fts_is_float(at)<br>  fts_is_symbol(at)<br>  fts_is_object(at)</pre>The type of an atom is an FTS class (<span style="font-style: italic;">fts_class_t*</span>). Pseudo classes are provided for the primitive types <span style="font-style: italic;">int</span>, <span style="font-style: italic;">float</span> and <span style="font-style: italic;">symbol</span>. For atoms with an object(actually a pointer to an object) as value the atom type is the class ofthe object.<br><br>If the method <span style="font-style: italic;">coucou_set_number</span>from above is declared for number arguments only, the method will onlybe called with a single float or int atom as argument. The function <span style="font-style: italic;">fts_get_number_int</span> returns an intvalue of the argument value <span style="font-style: italic;">at[0]</span>.<br><br>The arguments of varargs methods are not type checked by the FTS methodpatcher when sending messages or values between objects. A methoddeclared for varargs must check the number and type of the arguments inthe message body:<br><pre>  static void<br>  coucou_set_varargs(fts_object_t *o, int winlet, fts_symbol_t s, int ac, const fts_atom_t *at)<br>  {<br>    coucou_t *self = (coucou_t *)o;<br><br>    if(ac &gt; 0 &amp;&amp; <span style="font-weight: bold;">fts_is_number</span>(at))<br>      n = <span style="font-weight: bold;">fts_get_number_int</span>(at);<br>    else<br>      n = 0;<br><br>    if(n &gt; 0)<br>      self-&gt;count = n;<br>    else<br>      self-&gt;count = 0;<br>  }<br></pre><hr style="width: 100%; height: 2px;"><h3><a name="Method_invocation_"></a>Method invocation<br></h3>Methods usually change the state of the object and/or send output froman object or return a value. Basically there are two contexts for theinvokation of methods: the values and messages passed between connectedobjects and the direct sending of a message to an object using thefunction <span style="font-style: italic;">fts_send_message</span>.<br><br>Methods which are sending output via outlets use the followingfunctions called with the object is self and the index of outlet:<br><pre>  fts_outlet_void(o, 0, n) /* same as fts_outlet_bang */<br>  fts_outlet_int(o, 0, n)<br>  fts_outlet_float(o, 0, f)<br>  fts_outlet_symbol(o, 0, s)<br>  fts_outlet_object(o, 0, obj)<br>  fts_outlet_atom(o, 0, a)<br>  fts_outlet_varargs(o, 0, out_ac, out_at)<br>  fts_outlet_message(o, 0, out_s, out_ac, out_at);<br></pre>If an object outputs from multiple outlets at the same time, byconvention this is done in right to left order (highest to lowest index).<br><pre>  {<br>    fts_atom_t *store;<br>    int i, n;<br><br>    /* ... */<br><br>    for(i=n-1; i&gt;=0; i--)<br>      <span style="font-weight: bold;">fts_outlet_atom</span>(o, i, store + i);<br>  }<br></pre>Alternatively a method of a given object can be invoked by sending amessage using the following functions:<br><pre>  fts_send_message(target, mess_s, mess_ac, mess_at)<br><br> &nbsp;fts_send_message_varargs(cl, mess_s, mess_ac, mess_at)<br></pre>The second function only invokes methods declared as varargs andignores any further method declaration for the same message.<br><br>Methods invoked in this way can return values using the followingfunctions with a pointer to an atom or a value:<br><pre>&nbsp; fts_return(ap)<br>  fts_return_int(n)<br>  fts_return_float(f)<br>  fts_return_symbol(s)<br>  fts_return_object(obj)</pre>It is the reponsibitity of the calling routine to clear the globalreturn value of the FTS object system and to interpret the return valueafter having sent the message.<br><pre>  {<br>    fts_object_t *target;<br>    int size;<br><br>    /* ... */<br><br>    /* first void return value */<br>    fts_set_void(<span style="font-weight: bold;">fts_get_return_value</span>());<br><br>    /* send the message */<br>    fts_send_message(target, fts_new_symbol("size"), 0, NULL):<br><br>    /* get return value */<br>    if(!fts_is_void(fts_get_return_value()))<br>      size = fts_get_int(<span style="font-weight: bold;">fts_get_return_value</span>());<br>    else<br>      size = -1;<br><br>    /* ... */<br><br>  }<br></pre><hr style="width: 100%; height: 2px;"><h3><a name="Error_handling"></a>Error handling</h3>In order to signal an error a method (as well as a constructor) can usethe function <span style="font-style: italic;">fts_object_error</span>.The function is called with the object and a format string such as in <span style="font-style: italic;">post</span> or <span style="font-style: italic;">fprintf</span>.<br><br><pre>  static void<br>  coucou_init(fts_object_t *o, int winlet, fts_symbol_t s, int ac, const fts_atom_t *at)<br>  {<br>    coucou_t *self = (coucou_t *)o;<br><br>    self-&gt;count = 0;<br><br>    if(ac &gt; 0)<br>    {<br>      if(fts_is_number(at))<br>        self-&gt;count = fts_get_number_int(at);<br>      else<br>        <span style="font-weight: bold;">fts_object_error</span>(o, "bad argument %s for object coucou", fts_class_get_name(fts_get_class(at)));<br>    }<br>  }<br></pre>Any call of this function during the creation of the object (in thecreator or a method called by the creator) will result in aninstantiation error. All other calls are handled as runtime errors.<br><br><hr style="width: 100%; height: 2px;"><br><br><br></body></html>