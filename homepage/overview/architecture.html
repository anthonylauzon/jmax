<HTML>
<HEAD><TITLE>jMax Overview - System Architecture</TITLE></HEAD>
<BODY LANG="EN" BACKGROUND="" BGCOLOR="#FFFFFF">
<A NAME="TOP"></A>

<!-- IRCAM banner -->
<TABLE WIDTH=100% BGCOLOR="#000000" CELLSPACING=0 CELLPADDING=0 BORDER=1>
<TR><TD VALIGN=CENTER>
  <IMG SRC="../images/ircam_logo.jpeg" ALT="IRCAM - Centre Georges Pompidou"></TD></TR>
</TABLE>
&nbsp

<TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0>
<TR>
  <TD ALIGN=CENTER VALIGN=MIDDLE>
    <A HREF="http://www.ircam.fr/jmax/"><IMG SRC="../images/jmax_logo_small.gif" ALT="jMax" BORDER=0></A>
  <TD ALIGN=CENTER VALIGN=MIDDLE>
    <IMG SRC="../images/dot.gif" HSPACE=20 BORDER=0>
    <A HREF="./overview.html"><FONT FACE="helvetica" SIZE=6>overview</FONT></A>
</TR>
</TABLE>
&nbsp
<HR>


<H1>System Architecture</H1>

<H2>Client/Server</H2>

<P>
Often used in other fields of computer applications, a client/server architecture
like that of <I>j</I>Max can be seen as an efficient framework within which to 
structure complex applications, possibly running on a network (Déchelle et al. 1994).
The system is made of two types of components -- the server and clients -- 
communicating via a specified and hardware-independent protocol. 
This structure allows the two components to run on different machines, 
as can be seen in the familiar example of 
an http web server and various clients' web browsers. 

<P>
Figure 1 gives a block diagram of the global <I>j</I>Max system architecture,
showing the client/server components:

<P>
<CENTER>
<!-- architecture image -->
  <IMG SRC="../images/jmax_arch.gif" BORDER=1><BR>
  Figure 1: <I>j</I>Max system architecture
</CENTER>

<P>
With this flexible architecture, many different implementations of a
<I>j</I>Max system are possible, with client and server running on the
same or different machines, or even communicating across remote
networks. 
This allows, for instance, the dedicating of one machine to real-time processes, 
thus removing it from any graphical interaction, or the use of graphic-less
server machines to run the DSP kernel.

<P>
The client/server communication protocol used in <I>j</I>jMax can use different transport
layers: standard UNIX pipes, TCP/IP connections or shared memory in specialized 
hardware architectures. 
Clients, server and transport are completely orthogonal to each other and work
together in a completely transparent way: any client can connect to
any server as long as they can be connected by a physical transport
that supports the protocol.


<H2><I>j</I>Max Server (<I>FTS</I>) architecture</H2>

<P>
The <I>j</I> server is a complete rewriting of the FTS "monitor" (Puckette 1991) for
the ISPW platform, which was itself a declination of the Max program initially
developed for the Macintosh.

<P>
The backbone of FTS is its message system, a new implementation of the earlier 
Max message system. 
The basic concepts of this message system have been described in 
(Déchelle and De Cecco 1995a).
The main difference from the original Max message system is portability; as a consequence, 
FTS has a programming interface which is not compatible, either source or binary, 
with the original Max API.

<P>
Figure 2 presents the inside architecture of the FTS server, that 
now separates into four levels:
<UL>
<LI> the <I> system </I> level: memory management, hardware dependencies, modules abstraction
<LI> the <I> language </I> level: the message system itself, FTL vector computation engine<BR> 
(Déchelle and De Cecco 1995a)
<LI> the <I> runtime </I> level: I/O, devices, timing services, scheduler
<LI> the <I> tiles </I> level: all the sub-tasks that are scheduled (control, DSP, I/O)
</UL>

<P>
<CENTER>
<!-- architecture image -->
  <IMG SRC="../images/jmax_server_arch.gif" BORDER=1><BR>
  Figure 2: Max system architecture
</CENTER>


<P>
The FTS kernel, differing from the architecture described in (Déchelle and De Cecco 1995a), 
integrates the message system and contains no object libraries. These libraries are now dynamically 
loaded, leading to a kernel that is very compact and fully configurable.

<P>
The main object library provides an object set that is compatible with the object set
of the ISPW version; the compatibility has been tested on a wide range of musical
applications and has shown its effectiveness in facilitating the porting of earlier repertoire.


<H3>Portability issues </H3>

<P>
As mentioned, portability is an essential issue in the jMax
project. Over the course of the jMax development, several considerations have been key 
in obtaining a high level of portability of both jMax clients and server.

<P>
The initial choice of Java for the graphical user interface left aside the question
of the portability of the graphical environment. What would normally be, in general, an
overwhelming question, became a moot point with the use of Java.

<P>
On the server side, the FTS portability results from two sets of considerations, 
one independent from the application field and more related to software quality 
and software engineering issues, the other strictly dependent on the underlying 
application.

<P>
C language portability has been largely studied (Horton 1990, Dolenc et al 1990).
A first and widely-accepted
recommendation is that portability and "well-written" code go hand-in-hand.
There are a number of standard style guides in the public domain 
(Cannon et al 1990, Stallman 1998), and the problem
is probably less "Which one to choose?" than "Should I follow a style guide?"

<P>
The choice of the jMax development team, since the beginning of the project, 
has been a commitment to code quality, based on the fact that well-written 
code is "easier" to understand, maintain, port and make evolve. 
As a consequence of such a "conviction", a style guide for the C programming 
language has been used and recommended for all development around FTS 
(Déchelle and De Cecco 1995b).

<P>
Regarding FTS, however, an obvious statement is that some of the code is inherently
non-portable: audio I/O, MIDI I/O, system real-time scheduling policy, vector arithmetic
optimizations, to cite only the most important elements. The main task in FTS development
for portability has thus been to <I>encapsulate</I> these hardware and system dependencies,
and to establish <I>generic</I> programming interfaces that provide in an 
abstract, system and hardware-independent way the functionalities described.

<P>
The main advance in system portability has been the introduction of the concept
of <I>devices</I>: an FTS device (Dechelle and De Cecco 1995) is an abstraction 
supporting a small number of I/O and control operations with an API that is totally 
hardware independent.
A device is known by a name, and the corresponding code can be dynamically loaded
under control of the UCS configuration facility.
Both audio and MIDI I/O are completely handled by devices, thus restricting the
code that has to be rewritten to a small set of files, typically one or two.
The other advantage is that the functions that are to be re-implemented are
totally specified, either in terms of implementation or in terms of interface.

<P>
As a result of these considerations, the FTS server achieves a high level of 
portability.
Experience has shown that the porting cost to a Unix-like operating system 
(Linux, Rhapsody,...), without
audio (i.e. just for performance measurement), can be measured in days and that
the time needed to write the devices' code for the same type of systems can be 
measured in weeks, usually less than two.


<H2><I>j</I>Max client architecture</H2>

<P>
The "client side" of the <I>jMax</I>architecture comprises a graphic
development environment, a set of generic libraries providing access to the
underlying FTS engine (the "application layer"), a set of special editors,
and a set of development tools and utilities. 
The overriding principle on which the "client" structure is based is that of 
<I>extensibility:</I> the structure is strongly modular and dynamic, every 
subsystem is independent and configurable, and the addition of new features, 
editors and controllers should be possible with little or no extra effort 
from the user's point of view (Maggi 1996).

<P>
In the design of the user interface for the development environment,
where one assembles and edits objects via patchcords, etc., two
approaches have been taken to the issue of compatibility with the
previous MAX user-interface paradigm:

<UL>
<LI> compatibility: let the user deal with known objects in a known
way, and offer graphic enhancements of old functionalities in a way
that can be perceived as an "extension" of known interactions. In
other words, the planned migration of old users toward the new
architecture should be as smooth as possible. (Note that improvements
in the user interaction may occur in cases where the old paradigm was
insufficient or unclear.)
<LI> enhancements: add completely new features in a "completely new"
fashion, refusing to stretch old models "to the limits" in order to
introduce new modes of interaction. In synthesis, offer and encourage
the use of different paradigms when suitable and/or needed, and always
offer the developer the possibility to create their own.
</UL>

<P>
One of the most innovative features of jMax is the introduction of a
scripting language extensively used in the entire system. The chosen
scripting language is Tcl (Ousterhout 1994), which has a fully supported 
JAVA implementation (Sun Microsystems 1997).
The default graphic configuration of jMax presents a Tcl interpreter and a
related console window.
The choice of Tcl comes from the following considerations:
<UL>
<LI> Tcl is one of the simplest scripting languages, easy to learn and easy to
use. At the same time it offers the needed power to handle rich and complex
control structures (Ousterhout 1997).
<LI> The Java implementation of Tcl, starting from the first Jacl
implementation (Cornell University, 1997), has now been successfully
integrated into the Sun Java tool suite, and is completely supported and
documented (Sun Microsystems 1997).
<LI> Given the high level of integration between the Java-based Tcl
interpreter and the underlying Java system, the user can often choose to
implement new features either in Java or in Tcl (Ousterhout 1997, Stanton 1998).
</UL>

<P>
From the user point of view, the Tcl interpreter is also a simple way to
interact with the system at different levels: from simple control scripts written 
to handle graphic behaviors or repetitive tasks, to the production of new TCL 
commands to be used in the control of new (or even pre-existing) functionalities.

<P>
Figure 3 gives an overview of the jMax client architecture.

<P>
<CENTER>
<!-- architecture image -->
  <IMG SRC="../images/jmax_client_arch.gif" BORDER=1><BR>
  Figure 3: <I>j</I>Max client architecture
</CENTER>


<H3>The Client Application Layer</H3>

<P>
In the previous version of Max/FTS, using either the NeXTSTEP or the X-Windows
version of Max (Déchelle et al. 1994, Déchelle and De Cecco 1995), communication 
with the FTS server was handled on the client side by the "client library", a C library 
that provided only a low level access to the client/server protocol.

<P>
The decision to entirely rewrite the client environment in JAVA meant that, 
as a first consequence, the client library also had to be completely rewritten. 
The decision was then made to extend in a large way the services that it offered and
to take full advantage of the object-oriented language used for the implementation.

<P>
This new version of the client library essentially provides a JAVA abstraction
of the FTS objects. It must be noted that this "mirroring" applies only 
to the edition operations and <I>not</I> to the execution, and keeps only the information
that is needed for graphical editing and interaction. As a consequence,
the application layer is not a JAVA implementation of the FTS message system.

<P>
The application layer is built around the concept of <I>properties</I>: a property
is a named data attached to an FTS object. For instance, the state of an object
is a property. Properties are dynamic, and a subset of the FTS message system
API allows the FTS object programmer to manage the object properties.

<P>
The application layer provides all the basic operations that a client can require
of FTS objects: 
<UL>
<LI> create an object in FTS 
<LI> delete this object
<LI> connect two objects
<LI> change a property of the FTS object
<LI> install an event handler that will be invoked when a property of the FTS object has 
changed
</UL>

<P>
The use of the property concept allows us to handle in a very generic and elegant way
the "update" mechanism, by which an object in FTS (for instance, an object storing
a number) can inform its corresponding graphical object (for instance, a slider
or a number box) that a new value should be displayed.

</BODY>
</HTML>
