/* * jMax * Copyright (C) 1994, 1995, 1998, 1999 by IRCAM-Centre Georges Pompidou, Paris, France. *  * This program is free software; you can redistribute it and/or * modify it under the terms of the GNU Lesser Lesser General Public License * as published by the Free Software Foundation; either version 2.1 * of the License, or (at your option) any later version. *  * See file COPYING.LIB for further informations on licensing terms. *  * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU Lesser General Public License for more details. *  * You should have received a copy of the GNU Lesser Lesser General Public License * along with this program; if not, write to the Free Software * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. *  */#define HACK_FOR_CRASH_ON_EXIT_WITH_PIPE_CONNECTION/* Define this if you want logs of symbol cache hit *//* #define CACHE_REPORT *//* #define CLIENT_LOG */#include <fts/fts.h>#include <ftsconfig.h>#if HAVE_ALLOCA_H#include <alloca.h>#endif#if HAVE_UNISTD_H#include <unistd.h>#endif#include <ftsprivate/sched.h>#include <ftsprivate/bmaxfile.h>#include <ftsprivate/object.h>#include <ftsprivate/patfile.h>#include <ftsprivate/package.h>#include <ftsprivate/tokenizer.h>#include <ftsprivate/client.h>#include <ftsprivate/errobj.h>#include <ftsprivate/audio.h>#include <ftsprivate/audioconfig.h> /* requires audiolabel.h */#include <ftsprivate/midi.h>#include <ftsprivate/config.h> /* requires audioconfig.h and midi.h */#include <ftsprivate/loader.h>#include <string.h>#include <stdlib.h>#include <ftsprivate/connection.h>#include <ftsprivate/patcher.h>#include <ftsprivate/client.h>#include <ftsprivate/protocol.h>#include "unixfunc.h"fts_class_t *fts_client_class;static fts_symbol_t s_remove_object;/* Predefined ids */#define FTS_CLIENT_ROOT_OBJECT_ID 0#define FTS_CLIENT_CLIENT_OBJECT_ID 1/*********************************************************************** * * client table handling * */static fts_stack_t client_table;static int client_table_add( client_t *client){  fts_stack_push( &client_table, client_t *, client);  return fts_stack_top( &client_table);}static void client_table_remove( int id){  ((client_t **)fts_stack_base( &client_table))[id] = 0;}static void client_table_init( void){  fts_stack_init( &client_table, client_t *);  client_table_add( 0); /* so that first client will have id 1 */}#define client_table_get(I) ((client_t **)fts_stack_base( &client_table))[(I)]client_t *object_get_client( fts_object_t *obj){  int index;  index = fts_object_get_client_id( obj );  if (index < 0 || index >= fts_stack_size( &client_table))    return NULL;  return client_table_get(index);}/*********************************************************************** * * client object (the object that is created on new client connections) * */struct _client_t {  fts_object_t head;  /* Client id */  int client_id;  /* Object table */  fts_hashtable_t object_table;  /* object id count */  int object_id_count;  /* Root patcher */  fts_object_t *root_patcher;};/*---------------------------------------------------------------------- * Object table */static fts_object_t *client_get_object( client_t *this, int id){  fts_atom_t k, v;  fts_set_int( &k, id);  if ( !fts_hashtable_get( &this->object_table, &k, &v))    return NULL;  return fts_get_object( &v);}static void client_release_object( client_t *this, fts_object_t *object){  fts_atom_t k;  fts_set_int( &k, fts_object_get_id( object));  fts_hashtable_remove( &this->object_table, &k);  fts_object_set_id( object, FTS_NO_ID);  fts_object_set_client_id( object, FTS_NO_ID);}static void client_register_object( client_t *this, fts_object_t *object, int object_id){  fts_atom_t k, v;  if (object_id <= FTS_NO_ID)  {    object_id = this->object_id_count;    this->object_id_count += 2;   }  fts_set_int( &k, object_id);  fts_set_object( &v, object);  fts_hashtable_put( &this->object_table, &k, &v);  fts_object_set_id( object, object_id);  fts_object_set_client_id( object, this->client_id);}/*---------------------------------------------------------------------- * Client object methods */static void client_receive( fts_object_t *o, int size, const unsigned char* buffer){}static void client_new_object( fts_object_t *o, int winlet, fts_symbol_t s, int ac, const fts_atom_t *at){}static void client_set_object_property( fts_object_t *o, int winlet, fts_symbol_t s, int ac, const fts_atom_t *at){}static void client_connect_object( fts_object_t *o, int winlet, fts_symbol_t s, int ac, const fts_atom_t *at){}static void client_load_patcher_file( fts_object_t *o, int winlet, fts_symbol_t s, int ac, const fts_atom_t *at){}fts_patcher_t *fts_client_load_patcher(fts_symbol_t file_name, int client_id){  return 0;}static void client_load_project( fts_object_t *o, int winlet, fts_symbol_t s, int ac, const fts_atom_t *at){}static void client_load_package( fts_object_t *o, int winlet, fts_symbol_t s, int ac, const fts_atom_t *at){}static void client_load_summary( fts_object_t *o, int winlet, fts_symbol_t s, int ac, const fts_atom_t *at){}static void client_get_project( fts_object_t *o, int winlet, fts_symbol_t s, int ac, const fts_atom_t *at){}static void client_get_config( fts_object_t *o, int winlet, fts_symbol_t s, int ac, const fts_atom_t *at){}static void client_shutdown( fts_object_t *o, int winlet, fts_symbol_t s, int ac, const fts_atom_t *at){}static void client_predefine_objects( client_t *this){#ifdef HACK_FOR_CRASH_ON_EXIT_WITH_PIPE_CONNECTION  client_register_object( this, (fts_object_t *)fts_get_root_patcher(), FTS_CLIENT_ROOT_OBJECT_ID);#else  this->root_patcher = fts_object_create_in_patcher( patcher_class, fts_get_root_patcher(), 0, 0);  if ( !this->root_patcher)  {    fts_object_error( (fts_object_t *)this, "cannot create client root patcher");    return;  }  fts_patcher_add_object(fts_get_root_patcher(), this->root_patcher);  fts_object_refer( this->root_patcher);  client_register_object( this, (fts_object_t *)fts_get_root_patcher(), FTS_CLIENT_ROOT_OBJECT_ID);#endif  client_register_object( this, (fts_object_t *)this, FTS_CLIENT_CLIENT_OBJECT_ID);}static void client_init( fts_object_t *o, int winlet, fts_symbol_t s, int ac, const fts_atom_t *at){  client_t *this = (client_t *)o;  this->client_id = client_table_add( this);  this->object_id_count = 17;  fts_hashtable_init( &this->object_table, FTS_HASHTABLE_MEDIUM);  client_predefine_objects( this);}static void client_delete( fts_object_t *o, int winlet, fts_symbol_t s, int ac, const fts_atom_t *at){  client_t *this = (client_t *)o;  fts_object_release( this->root_patcher);  client_table_remove( this->client_id);  fts_hashtable_destroy( &this->object_table);}static void client_instantiate(fts_class_t *cl){  fts_class_init(cl, sizeof( client_t), client_init, client_delete);}/*********************************************************************** * * Client message sending * ***********************************************************************/typedef void (*client_send_message_fun_t)(fts_object_t *obj, fts_symbol_t selector, int ac, const fts_atom_t *at);static client_send_message_fun_t client_send_message_fun = NULL;void fts_set_client_send_message_fun(void *fun){  client_send_message_fun = (client_send_message_fun_t)fun;}void fts_client_start_message( fts_object_t *obj, fts_symbol_t selector){}void fts_client_add_int( fts_object_t *obj, int v){}void fts_client_add_float( fts_object_t *obj, float v){}void fts_client_add_symbol( fts_object_t *obj, fts_symbol_t v){}void fts_client_add_string( fts_object_t *obj, const char *v){}void fts_client_add_object( fts_object_t *obj, fts_object_t *v){}void fts_client_add_atoms( fts_object_t *obj, int ac, const fts_atom_t *at){}void fts_client_done_message( fts_object_t *obj){}void fts_client_send_message( fts_object_t *obj, fts_symbol_t selector, int ac, const fts_atom_t *at){  if(client_send_message_fun != NULL)    client_send_message_fun(obj, selector, ac, at);}void fts_client_register_object(fts_object_t *obj, int client_id){  client_t *client;  if(client_id <= FTS_NO_ID)    client_id = fts_object_get_client_id((fts_object_t *)fts_object_get_patcher(obj));    client = client_table_get(client_id);  if(!client)  {    fts_log("[client] fts_client_register_object: cannot get id\n");          return;  }  client_register_object( client, obj, FTS_NO_ID);}fts_object_t *fts_client_get_object(int obj_id, int client_id){  client_t *client = client_table_get(client_id);  if(!client)  {    fts_log("[client] fts_client_get_object: cannot get id\n");          return NULL;  }    return client_get_object( client, obj_id);}void fts_client_release_object(fts_object_t *obj){  if(fts_object_has_id(obj))  {    int client_id = fts_object_get_client_id( obj);    client_t *client = client_table_get(client_id);        if (!client)  	{   	  fts_log("[client] fts_client_release_object: Cannot release object\n");        	  return;  	}        client_release_object( client, obj);  }}void fts_client_release_all_objects(int client_id){  fts_iterator_t objects;  fts_atom_t v;  fts_object_t *obj;  client_t *client = client_table_get(client_id);     if(!client)  {    fts_log("[client] fts_client_release_object: Cannot release object\n");        	return;   }    fts_hashtable_get_values(&client->object_table, &objects);    while(fts_iterator_has_more(&objects))  {    fts_iterator_next(&objects, &v);    obj = fts_get_object(&v);        fts_object_set_id( obj, FTS_NO_ID);      fts_object_set_client_id( obj, FTS_NO_ID);  }    fts_hashtable_clear(&client->object_table);}/************************************************************************* Initialization**/voidfts_kernel_client_init( void){  client_table_init();  s_remove_object = fts_new_symbol( "removeObject");    fts_client_class = fts_class_install( NULL, client_instantiate);}/** EMACS ** * Local variables: * mode: c * c-basic-offset:2 * End: */